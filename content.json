{"meta":{"title":"MarkLily","subtitle":"Tell me what you want,and i'll aviod it","description":"","author":"CJBLUE","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2020-02-23T11:20:33.000Z","updated":"2023-07-13T13:09:23.441Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"CJBLUE_MarkLilyCJBLUEbluesMediumSlateBlueSlateBlueDarkSlateBlueBlueMediumBlueMidnightBlueDarkBlueNavyRoyalBlueCornflowerBlueLightSteelBlueLightSlateGrayDodgerBlueAliceBlueSteelBlueLightSkyBlueSkyBlueDeepSkyBlueLightBluePowderBlueAzure是音乐MarkLily 他是Department of Integration (DOI)的社会工作人员.他是魔女Callie Maggotbone的男朋友，也是僵尸Randall 和巫师Leonard 的朋友.马克究竟有多高尚不得而知，但大多数时候他都比 6 英尺 2 英寸的格莱姆斯高一点. MusicGuns and roses the Beatles the rolling stones the libertines galaxies 500 Oasis Pink Floyd Arctic Monkeys DarkBlue Dire Straits Lynyrd Skynyrd Deep Purple Avenged Sevenfold Baby shambles Blondie David Bowie pixies Fun. Joy Division Led Zeppelin Mansun Peter Doherty the stone roses Sonic Youth the verve Violent Femmes The SmithsThe Strokes The last Shadow PuppetsRadiohead Tell You Later·20190502·20200909·20220219· Began with taking me to the hospital, ended with it too. circle20210302Seems like i&#39;m 70% fine... Snap Out of It Lililin ·20230602·"}],"posts":[{"title":"git-10-git与github远程仓库","slug":"git/git-10-git与github","date":"2021-08-27T02:53:22.000Z","updated":"2021-08-27T04:37:01.192Z","comments":true,"path":"2021/08/27/git/git-10-git与github/","link":"","permalink":"http://example.com/2021/08/27/git/git-10-git%E4%B8%8Egithub/","excerpt":"将git本地仓库与github远程仓库建立连接","text":"将git本地仓库与github远程仓库建立连接 github-远程仓库准备工作1. 创建一个github仓库 填写用户名 添加一个 readme.md 2. 添加ssh key具体操作见 建立连接本地创建仓库1. 修改默认分支名在 bash内输入 ： 1226676@DESKTOP-KEJKGL7 MINGW64 /a$ git config --global init.defaultBranch main 2. 创建本地仓库在 bash内 ： 12345678910111226676@DESKTOP-KEJKGL7 MINGW64 /a$ mkdir gitl26676@DESKTOP-KEJKGL7 MINGW64 /a$ cd gitl26676@DESKTOP-KEJKGL7 MINGW64 /a/gitl$ git initInitialized empty Git repository in A:/gitl/.git/26676@DESKTOP-KEJKGL7 MINGW64 /a/gitl (main) 第一步mkdir创建文件夹 第二步init创建仓库 由于我们已经修改了初始分支名, 此时所处分支为 main 建立连接1. 复制ssh地址在github新建仓库页面复制仓库ssh地址 2. 建立连接1226676@DESKTOP-KEJKGL7 MINGW64 /a/gitl (main)$ git remote add origin git@github.com:MarkLilyC/gitl.git 3. 第一次push此时本地仓库为空文件 ，尝试进行第一次push 123426676@DESKTOP-KEJKGL7 MINGW64 /a/gitl (main)$ git push -u origin mainerror: src refspec main does not match anyerror: failed to push some refs to &#x27;github.com:MarkLilyC/gitl.git&#x27; 提示报错 ，这是因为本地为空文件夹 ，空文件夹不能提交 解决办法1-pull仓库中的readme.md123456789$ git pull origin mainremote: Enumerating objects: 9, done.remote: Counting objects: 100% (9/9), done.remote: Compressing objects: 100% (5/5), done.remote: Total 9 (delta 0), reused 6 (delta 0), pack-reused 0Unpacking objects: 100% (9/9), 1.18 KiB | 2.00 KiB/s, done.From github.com:MarkLilyC/gitl * branch main -&gt; FETCH_HEAD * [new branch] main -&gt; origin/main 此时本地文件夹中出现了readme.md ，再次push ： 123426676@DESKTOP-KEJKGL7 MINGW64 /a/gitl (main)$ git push -u origin mainEverything up-to-dateBranch &#x27;main&#x27; set up to track remote branch &#x27;main&#x27; from &#x27;origin&#x27;. 解决办法2-在本地创建空文件在已经实现方法一的本地仓库内无法再实现方法二 因此删除已经创建的仓库 ，创建一个新的本地仓库与远程仓库建立连接 在本地创建一个空的测试文件demo.txt ： 1234567826676@DESKTOP-KEJKGL7 MINGW64 /a/gitl (main)$ touch demo.txt26676@DESKTOP-KEJKGL7 MINGW64 /a/gitl (main)$ git add . &amp;&amp; git commit -m &quot;touch a empty file&quot;[main (root-commit) b75675c] touch a empty file 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 demo.txt 进行push 1234567891026676@DESKTOP-KEJKGL7 MINGW64 /a/gitl (main)$ git push -u origin mainTo github.com:MarkLilyC/gitl.git ! [rejected] main -&gt; main (fetch first)error: failed to push some refs to &#x27;github.com:MarkLilyC/gitl.git&#x27;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details. 此时仍然报错 ，因为本地和远程文件差异 ，可以采用强制推送 ： 12345678926676@DESKTOP-KEJKGL7 MINGW64 /a/gitl (main)$ git push -u origin main -fEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Writing objects: 100% (3/3), 216 bytes | 216.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0), pack-reused 0To github.com:MarkLilyC/gitl.git + ae7587d...b75675c main -&gt; main (forced update)Branch &#x27;main&#x27; set up to track remote branch &#x27;main&#x27; from &#x27;origin&#x27;. 但强制推送会使得远程仓库统一到本地仓库的版本 ，如远程仓库中的readme.md文件丢失","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-09-冲突","slug":"git/git-09-分支合并(3)","date":"2021-07-13T06:53:22.000Z","updated":"2021-08-27T02:53:31.444Z","comments":true,"path":"2021/07/13/git/git-09-分支合并(3)/","link":"","permalink":"http://example.com/2021/07/13/git/git-09-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6(3)/","excerpt":"在以上两种合并方式中 ，两分支无冲突 ，","text":"在以上两种合并方式中 ，两分支无冲突 ， conflict-冲突冲突当我们在合并前, master内也进行了修改呢 准备工作版本回退(撤销合并)我们使用git reset来将master回退到合并前 : 12$ git reset --hard HEAD^HEAD is now at dfb30b7 test merging 此处HEAD^中^的个数应视合并后, 我们对master是否做出其他修改与提交 此时我在合并后, 并未修改master, 因此只使用一个^来回退到上一个版本便能回到合并前版本 检查文件内容 :1. master 1234------------add a line to test logging------------add a line to test merging 确认此时master已经成功回退 2. tb 123456789public place------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1------------add a line to test --no-ff 2 tb版本并未受到master回退影响 测试冲突1. 将master 与 newb内文件修改为1234567public place------------add a line to test logging------------add a line to test merging------------add a line to test conflic 即我们同时对test.txt在两分支内做了修改 且修改的区域重合 提交修改 : 123$ git add . &amp;&amp; git commit -m &quot;merging to test conflict&quot;[master 90a5bc1] merging to test conflict 1 file changed, 2 insertions(+) 2. 在master内快进合并1234$ git merge tbAuto-merging test.txtCONFLICT (content): Merge conflict in test.txtAutomatic merge failed; fix conflicts and then commit the result. 如git提示:自动合并分支失败 因为两个文件内容有冲突,需要我们修改冲突部分后再行提交 3. 解决冲突1. 打开master内test.txt文件,如下: 123456789101112public place------------add a line to test logging------------add a line to test merging&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADadd a line to test conflic=======add a line to test --no-ff 1------------add a line to test --no-ff 2&gt;&gt;&gt;&gt;&gt;&gt;&gt; newb 其中&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD到&gt;&gt;&gt;&gt;&gt;&gt;&gt; newb之间为冲突部分 其中 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD到=======之间为master分支更新的内容 =======到&gt;&gt;&gt;&gt;&gt;&gt;&gt; tb之间为tb分支更新的内容 我们注意在add a line to test merging下有一行-----, 在两者公共修改区域且二者内容一致, 因此不被标记为重复 2. 解决冲突 我们确定自己需要的更新内容,并将其余所有不需要的文字符号全部删掉,如此处我需要tb分支提交的修改,则我将test.txt内容修改为: 123456789public place------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1------------add a line to test --no-ff 2 3. 保存后,提交修改,便可提交此次合并: 12$ git add . &amp;&amp; git commit -m &quot;merging to test conflict&quot;[master bebd724] merging to test conflict 4.检查结果1. 查看master中文件内容 : 123456789public place------------add a line to test logging------------add a line to test merging-----------add a line to test --no-ff 1------------add a line to test --no-ff 2 2. 查看log 12345678910$ git log --graph --pretty=oneline --abbrev-commit* bebd724 (HEAD -&gt; master) merging to test conflict|\\| * 1bc5def (tb) add line to test --no-ff 2| * e156967 add line to test --no-ff 1* | 90a5bc1 merging to test conflict|/* dfb30b7 test merging* 4dbd6a8 test logging* dc8846c basic prop 可见这次解决冲突时我们新建的commit : merging to test conflict 怎样才算冲突 ?刚才的测试中, 我们在两分支内的修改区域有重叠且重叠区域内容有差异, 所以导致了conlicts的产生 那么什么样的才算conflic呢 ? 为方便演示, 我们在tb内使用git merge master将tb节点提前到与master相同 case1-只在一个分支内修改此case其实就是我们以上举例fast-forward与--no-ff的情况 此时由于只有分支出现修改, 合并必然是顺利进行的. 但我们依然可以进行简单验证 此时我们让master无修改master内 ; 123456789public place------------add a line to test logging------------add a line to test merging-----------add a line to test --no-ff 1------------add a line to test --no-ff 2 1. tb内新增 :即上面示例, 不再验证 2. tb内删减 : 1234567public place------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1 提交后合并 : 12345678910111213141526676@DESKTOP-KEJKGL7 MINGW64 /a/Git/gitlearn (tb)$ git add . &amp;&amp; git commit -m &quot;del 2 lines&quot;[tb 5d08a02] del 2 lines 1 file changed, 1 insertion(+), 3 deletions(-)26676@DESKTOP-KEJKGL7 MINGW64 /a/Git/gitlearn (tb)$ git checkout masterSwitched to branch &#x27;master&#x27;26676@DESKTOP-KEJKGL7 MINGW64 /a/Git/gitlearn (master)$ git merge tbUpdating 0427331..5d08a02Fast-forward test.txt | 4 +--- 1 file changed, 1 insertion(+), 3 deletions(-) 可见无冲突 3. tb内修改某处文字 : 先将master与tb撤销合并(版本回退) : 12345678910111226676@DESKTOP-KEJKGL7 MINGW64 /a/Git/gitlearn (master)$ git reset --hard HEAD^HEAD is now at 0427331 prop merge26676@DESKTOP-KEJKGL7 MINGW64 /a/Git/gitlearn (master)$ git checkout tbSwitched to branch &#x27;tb&#x27;26676@DESKTOP-KEJKGL7 MINGW64 /a/Git/gitlearn (tb)$ git reset --hard HEAD^HEAD is now at 0427331 prop merge 在tb内修改 : 123456789private place------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1------------add a line to test --no-ff 2 将第一行的public修改为private后提交, 回到master进行合并 : 12345678910111213141526676@DESKTOP-KEJKGL7 MINGW64 /a/Git/gitlearn (tb)$ git add . &amp;&amp; git commit -m &quot;public to private&quot;[tb 5bbed4d] public to private 1 file changed, 1 insertion(+), 1 deletion(-)26676@DESKTOP-KEJKGL7 MINGW64 /a/Git/gitlearn (tb)$ git checkout masterSwitched to branch &#x27;master&#x27;26676@DESKTOP-KEJKGL7 MINGW64 /a/Git/gitlearn (master)$ git merge tbUpdating 0427331..5bbed4dFast-forward test.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 可见无冲突 可见, 只对一个分支进行修改不会触发冲突 case2-同时修改1. 无重叠区域master内 : 123456789private place add words in master------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1------------add a line to test --no-ff 2 tb内 : 123456789private place------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1------------add a line to test --no-ff 2 add tail in tb 合并 : 12345$ git merge tbAuto-merging test.txtMerge made by the &#x27;recursive&#x27; strategy. test.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 此时会让我们输入commit message, 且此时采用recursive策略, 但无冲突 2. 有显性重叠区域此情况如上述测试冲突时的案例, 不再赘述 3,隐性重叠区域 我们在tb内$ git merge master, 同步二者节点 此时我们尚处tb, 故先对tb修改 : 123456789private place in master------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1------------add 我们删掉最后一行部分文字后提交 master : 1234567891011private place in master------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1------------add a line to test --no-ff 2 add tail in tb------------add a line in master to test invisible overlap 我们在最后添加两行后提交 进行合并 : 1234$ git merge tbAuto-merging test.txtCONFLICT (content): Merge conflict in test.txtAutomatic merge failed; fix conflicts and then commit the result. 这两个修改区域虽然看似没有重叠区 : tb是删除了一部分 master在tb删除那部分后添加了新内容看似二者没有重合 但我们尝试用文件写入的方式来分析合并过程 : 当我们要利用这两个文本来生成一个新文本时, 直到tb的最后一行的add结束, 整个过程顺利，tb中的add行原本部分被我们标识为以删除部分 此时, 我们发现master中剩余部分还有写入内容,并且add行后原本内容也在其中 因此会发生冲突 解决冲突 ： 此时master内test.txt文件内容为 ： 123456789101112131415private place in master------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1------------&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADadd a line to test --no-ff 2 add tail in tb------------add a line in master to test invisible overlap=======add&gt;&gt;&gt;&gt;&gt;&gt;&gt; tb 我们将文本内容修改为 ： 1234567891011private place in master------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1------------add a line to test --no-ff 2 add tail in tb------------add a line in master to test invisible overlap 提交修改后再次合并 123456726676@DESKTOP-KEJKGL7 MINGW64 /a/Git/gitlearn (master|MERGING)$ git add . &amp;&amp; git commit -m &quot;solve the conflicts&quot;[master 97e2307] solve the conflicts26676@DESKTOP-KEJKGL7 MINGW64 /a/Git/gitlearn (master)$ git merge tbAlready up to date. 合并成功","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-08-分支合并2","slug":"git/git-08-分支合并(2)","date":"2021-07-13T05:53:22.000Z","updated":"2021-08-20T04:37:40.408Z","comments":true,"path":"2021/07/13/git/git-08-分支合并(2)/","link":"","permalink":"http://example.com/2021/07/13/git/git-08-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6(2)/","excerpt":"鉴于fast-forward策略存在弊端 ，我们禁用ff进行分支合并","text":"鉴于fast-forward策略存在弊端 ，我们禁用ff进行分支合并 --no-ff-禁用ff我们希望将分支合并后, 开发分支tb的所有commit记录既能复制到master分支, 同时也保留一条分支tb自己的commit时间线, 以便我们区分各项工作是由谁进行的 此时我们需要使用--no-ff禁用fast-forward 经历上次合并后的分支图 tb分支上进行多次修改我们对tb分支内文件进行多次修改并提交 :1. 一次修改 1234567public place------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1 提交 : 123$ git add . &amp;&amp; git commit -m &quot;add line to test --no-ff 1&quot;[tb e156967] add line to test --no-ff 1 1 file changed, 2 insertions(+) 2. 二次修改 123456789public place------------add a line to test logging------------add a line to test merging------------add a line to test --no-ff 1------------add a line to test --no-ff 2 提交 : 123$ git add . &amp;&amp; git commit -m &quot;add line to test --no-ff 2&quot;[tb 1bc5def] add line to test --no-ff 2 1 file changed, 3 insertions(+), 1 deletion(-) 此时的节点图如果我们进行fast-forward合并的话, 节点图这样绘制是最好的, 因为我们会将master在C节点线上直接平行向前滑动到C3 但是我们接下来不会直接在C节点线上向前master, 所以最好这样绘制此时的节点图 : 很快你将看见这样绘制的好处 查看tb日志123456$ git log --graph --pretty=oneline --abbrev-commit* 1bc5def (HEAD -&gt; tb) add line to test --no-ff 2* e156967 add line to test --no-ff 1* dfb30b7 (master) test merging* 4dbd6a8 test logging* dc8846c basic prop 使用--no-ff进行合并基本语法 : 1git merge --no-ff &lt;name&gt; no前面是--, ff前是- 我们回到master进行合并 : 1$ git merge --no-ff tb 此时由于我们会为master在合并进行一次新的commit, 而非简单的共享tb的commit, 因此git会打开vim让我们填写commit message : 123456Merge branch &#x27;tb&#x27;# Please enter a commit message to explain why this merge is necessary,# especially if it merges an updated upstream into a topic branch.## Lines starting with &#x27;#&#x27; will be ignored, and an empty message aborts# the commit. 我们在第一行详细描述此次commit : 1Merge branch &#x27;tb&#x27; with --no-ff 随后便完成了此次合并 : 1234$ git merge --no-ff tbMerge made by the &#x27;recursive&#x27; strategy. test.txt | 4 ++++ 1 file changed, 4 insertions(+) 可见此次使用的是recursive策略, 而非简单的fast-forward 此时的节点图为方便理解log信息, 我们先来观察此时的节点图 : --no-ff会将tb分支的每次commit在master进行&quot;复制&quot;, 这样在主分支上保留完整commit记录的同时, tb分支自己记录也会被保留 但需要注意的是, 分支tb不会向前移动到与master相同节点 若要使二者节点一致, 可在tb内git merge master 检查master的log123456789$ git log --graph --pretty=oneline --abbrev-commit* c2aa7be (HEAD -&gt; master) Merge branch &#x27;tb&#x27; with --no-ff|\\| * 1bc5def (tb) add line to test --no-ff 2| * e156967 add line to test --no-ff 1|/* dfb30b7 test merging* 4dbd6a8 test logging* dc8846c basic prop 可见, 使用graph模式, log会显示合并的信息 并绘制类节点图","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-08-分支合并1","slug":"git/git-08-分支合并(1)","date":"2021-07-13T04:53:22.000Z","updated":"2021-08-20T04:37:45.077Z","comments":true,"path":"2021/07/13/git/git-08-分支合并(1)/","link":"","permalink":"http://example.com/2021/07/13/git/git-08-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6(1)/","excerpt":"当开发分支功能稳定后 ，我们希望将其中新代码添加到主分支 ，此时需要我们进行分支的合并","text":"当开发分支功能稳定后 ，我们希望将其中新代码添加到主分支 ，此时需要我们进行分支的合并 git merge-分支合并分支图我们将描述各个分支间关系及分支更新状态的图称为分支图, 如 ： 节点-B1-B3矩形框代表当前仓库的节点 : 当前节点作为上次commit的快照(shapshot), 会自动成为下个节点的父节点 我们此时只需简单将其理解为当前分支的一个版本指针 即此时我们分支master v1.1是出于节点B3, 上一次的commit信息即其形成的master v1.1的各项信息都存储在节点B3 如何看懂节点图上图中的版本更新前进关系是从左至右 而节点的指向关系是从右至左 这是因为每次生成的节点总是指向其父节点, 方便我们回溯 准备工作为方便演示, 我们删掉测试分支, 并在master内将test.txt修改为 : 1public place 并提交修改 : 123$ git add . &amp;&amp; git commit -m &quot;basic prop&quot;[master dc8846c] basic prop 1 file changed, 8 deletions(-) 新建测试分支tb检查此分支内test.txt文件内容 : 1public place fast-forward快进合并出现原因创建新分支时节点图此时master与tb都处于节点B3, 两分支文件内容一致 在新分支进行修改我们在tb分支内对test.txt文件进行以下修改 : 1. 添加进行日志检查的内容及commit message 123public place------------add a line to test logging 提交修改 : 123$ git add . &amp;&amp; git commit -m &quot;test logging&quot;[tb a4ce0d8] test logging 1 file changed, 2 insertions(+) 2. 添加进行日志检查的内容及commit message 12345public place------------add a line to test logging------------add a line to test merging 提交修改 : 123$ git add . &amp;&amp; git commit -m &quot;test merging&quot;[tb 0808891] test merging 1 file changed, 2 insertions(+) tb的日志1234$ git log --graph --pretty=oneline --abbrev-commit* dfb30b7 (HEAD -&gt; tb) test merging* 4dbd6a8 test logging* dc8846c (master) basic prop 此时我们多使用一个--graph以助于显示出分支合并信息 最新两条日志为我们在tb提交修改的日志 最后一条日志则是我们在master内进行准备工作时提交的日志 tb分支commit后的分支图 tb当前节点向前到达C1 而master由于未作任何改变, 则仍处于B3 此时也意味着二者内部的文件等信息已然不同 分支的合并为什么要合并假设此时我们对于tb开发的新功能满意, 则需要将master相关内容与tb同步, 也就是将二者进行分支合并, 最终使得master也到达C1的节点位置 分析我们的目标 : 我们要使master的代码和tb相同 此时master代码未改变 tb代码是在master基础上增加行 此时的合并, 我们可以简单理解为把tb的内容赋值给master 因此, 此时我们只需要简单将master指向tb即可 体现在节点上, 则是master向前滑动到了C1 1. 切换到master分支12$ git checkout masterSwitched to branch &#x27;master&#x27; 查看当前master分支log信息 : 12$ git log --graph --pretty=oneline --abbrev-commit* dc8846c (HEAD -&gt; master) basic prop 此时的master日志显示我们basic prop, 因为tb内的修改所处的节点超过了此时master节点, 所以master内的日志无法获取最新的commit 我们只需留意最新的log信息 2. 进行合并12345$ git merge tbUpdating dc8846c..dfb30b7Fast-forward test.txt | 4 ++++ 1 file changed, 4 insertions(+) 在主分支使用git merge &lt;name&gt; 将tb分支合并入主分支 从git提示中Fast-forward可见此次合并是快速合并: 3. 查看master内的文件12345public place------------add a line to test logging------------add a line to test merging 文件已经被快进到tb分支做出的修改版本 此时的节点图两分支处于同一节点 查看当前master分支log12345$ git log$ git log --pretty=oneline --abbrev-commit0808891 (HEAD -&gt; master, tb) test merginga4ce0d8 test loggingdc8846c basic prop 此时master分支同样处于C1处, 那么C1的节点信息两分支共享, 即完成了master的更新(分支的合并) 但我们注意到, 此时master内的文件被修改了, 但是却并没有创建新的commit, 而是共享了C1处其他分支的commit 此时我们可以理解为 : master被指向了tb, 此时二者不分你我, tb做的工作(commit)看起来也就是master做的工作 可见fast-forward方式并不会在合并后并不会不在主分支上创建一个新的commit idfast-forward的缺点如上所述, fast-forward后主分支不会创建新的commit id, 而是与分支共享分支所提交的commit及其id 这样所有分支的commit在一条线上, 我们无法区分到底是在哪个分支上做了哪些工作","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-07-分支基础","slug":"git/git-07-分支","date":"2021-07-13T04:15:22.000Z","updated":"2021-07-22T14:35:39.552Z","comments":true,"path":"2021/07/13/git/git-07-分支/","link":"","permalink":"http://example.com/2021/07/13/git/git-07-%E5%88%86%E6%94%AF/","excerpt":"","text":"git中对分支的操作是进行代码管理的重要功能 当某一个版本的代码性能稳定时 ，我们需要新建一个基于此主分支 此版本的分支进行开发 在分支上进行开发的一些好处有 ： 分支之间相互独立 ，分支上的开发不会影响到主分支上已经稳定的代码 多个分支可以提供给多个开发者进行不同模块的开发 git版本分支此时我们需要创建一个脱胎于主分支main ， 却又独立于主分支的开发分支用于进行新的开发 准备工作我们将test.txt文件内容修改为 : 1public place 并将此次修改提交 ，此时的主分支作为我们的稳定版本 git branch &lt;name&gt;创建分支创建分支使用 git branch &lt;name&gt;创建新分支 1$ git branch testbranch git branch查看分支123$ git branch* master testbranch 标注星号则为当前所处分支 checkout &lt;name&gt;切换分支切换分支12$ git checkout testbranchSwitched to branch &#x27;testbranch&#x27; 查看当前工作分支:123$ git branch master* testbranch 可见当前工作分支已被切换 查看testbranch内文件内容1public place 可见主分支master内的文件被’’复制’’到了分支’’testbranch’’中 分支比较查看master分支test1.txt1this is a test text 在testbranch内对test1.txt做出修改:12this is a test textadd a new line in tetsbranch 查看工作区状态12345678$ git statusOn branch testbranchChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 此时假设我们不对刚才所做的修改进行git add以及git commit提交,立马查看master分支此文件的状态 查看master内文件状态12this is a test textadd a new line in tetsbranch 会发现此文件在master分支同样呈现被修改后的版本 这是因为当我们在testbranch分支内对文件进行修改,但未将修改提交时,此文件还是以本地文件的形式存在,并未记录到git的版本标记中此时我们查看master主分支的工作区状态; 12345678$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 可见两分支工作区状态一致,这是因为此文件尚未在testbranch内提交,因此只被视为本地文件 将test.txt文件在testbranch内提交123456726676@DESKTOP-KEJKGL7 MINGW64 /a/git/gitlearn (testbranch)$ git add .26676@DESKTOP-KEJKGL7 MINGW64 /a/git/gitlearn (testbranch)$ git commit -m &quot;test&quot;[testbranch 6a60209] test 1 file changed, 1 insertion(+) 查看master内文件1this is a test text 可见master内text.txt文件呈现修改前的版本 查看master内工作区状态 123$ git statusOn branch masternothing to commit, working tree clean 工作树clean 当我们对testbranch修改后的文件做出提交后,再次对该文件做出修改,还是否会影响master?在修改前检查两分支工作树clean在testbranch内做出如下修改123this is a test textadd a new line in testbranchadd another line in testbranch testbranch状态12345678$ git statusOn branch testbranchChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 尝试在不提交修改的情况下切换分支12345$ git checkout mastererror: Your local changes to the following files would be overwritten by checkout: test.txtPlease commit your changes or stash them before you switch branches.Aborting git提示我们:checkout操作会覆盖本地对test.txt的修改 因此只能将在testbranch内的二次修改进行提交,后再切换分支 master内文件1this is a test text 123$ git statusOn branch masternothing to commit, working tree clean 文件和工作区当然不会发生变化 我们发现当在一个分支作出修改,但不提交时,两分支工作区状态 且文件版本一致.那如果我们在testbranch内做出修改,在master内提交,会有什么效果? 将testbranch内test.txt文件恢复至原版本1this is a test text 在testbranch内做出修改12this is a test textadd a line in tbranch 工作区状态; 12345678$ git statusOn branch testbranchChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 查看master文件: 12this is a test textadd a line in tbranch 工作区; 12345678$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 在master内提交修改查看master文件: 12this is a test textadd a line in tbranch 工作区: 123$ git statusOn branch masternothing to commit, working tree clean 查看testbranch文件: 1this is a test text 工作区; 123$ git statusOn branch testbranchnothing to commit, working tree clean 可见,对于本地文件,在哪个分支修改并不重要,重要的在于在哪个分支进行提交 删除分支当分支的测试功能完成,需要删除分支 123$ git branch -d testbrancherror: The branch &#x27;testbranch&#x27; is not fully merged.If you are sure you want to delete it, run &#x27;git branch -D testbranch&#x27;. 使用git branch -d branchname git提示两个分支尚未完全合并,此时所使用-d只能用于删除合并后的分支,此处我们先使用-D强制删除此分支 123456726676@DESKTOP-KEJKGL7 MINGW64 /a/git/gitlearn (master)$ git branch -D testbranchDeleted branch testbranch (was 3e68d78).26676@DESKTOP-KEJKGL7 MINGW64 /a/git/gitlearn (master)$ git branch* master 可见testbranch分支已被删除 创建新分支同时切换到该分支在创建新分支的同时切换到该分支; 12$ git checkout -b new_t_bSwitched to a new branch &#x27;new_t_b&#x27;","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-06-撤销修改","slug":"git/git-06-撤销修改","date":"2021-07-13T03:53:22.000Z","updated":"2021-07-22T14:39:01.926Z","comments":true,"path":"2021/07/13/git/git-06-撤销修改/","link":"","permalink":"http://example.com/2021/07/13/git/git-06-%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/","excerpt":"撤销修改可大致分为：从工作区撤销 从暂存区撤销以及版本库回退","text":"撤销修改可大致分为：从工作区撤销 从暂存区撤销以及版本库回退 上一节后我们的test.txt文件内容为this is a test txtfile, 且已提交到了版本库 为方便演示, 我们现在再对其增加一行: add a line to test recall 最终此文件内容为 : 12this is a test txtfileadd a line to test recall 撤销工作区内文件的修改基于以上修改, 我们不做任何提交 查看工作区状态12345678$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 提示我们使用git restore &lt;file&gt;...-撤销工作区的修改 修改前,进入test.txt文件查看文件内容12this is a test textnew line1 确认此时文件处于工作区并已修改 使用git restore撤销修改1$ git restore test.txt 进入test.txt文件查看文件内容1this is a test txtfile 说明对文件的修改已被撤销 查看工作区状态123$ git statusOn branch masternothing to commit, working tree clean 工作树呈现clean,说明文本之前的修改信息被删除,以及此次撤销修改也不被日志记录 checkout使用git checkout &lt;name&gt;也能撤销工作区内对文件的修改 从暂存区撤销修改我们将test.txt内容修改为 : 12this is a test txtfileadd a line to test recall 2 提交此次修改到暂存区 : 1226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git add . 文件差异1234567891011121314151617181920212226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff headdiff --git a/test.txt b/test.txtindex 2f59be1..7d6ebc9 100644--- a/test.txt+++ b/test.txt@@ -1 +1,2 @@ this is a test txtfile+add a line to test recall 226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff --cacheddiff --git a/test.txt b/test.txtindex 2f59be1..7d6ebc9 100644--- a/test.txt+++ b/test.txt@@ -1 +1,2 @@ this is a test txtfile+add a line to test recall 2 本地修改提交到暂存区后 工作区 暂存区无差异 工作区 版本库 与 暂存区 版本库差异相同 使用命令,将文件从暂存区撤销1$ git restore --staged test.txt 查看工作区状态12345678$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 工作区呈现我们对文件做出修改的状态: 提示我们将文件添加到暂存区,提示我们 提示我们使用restore撤销文件在工作区的修改 说明文件已经回到了我们对其做出修改且尚未提交到暂存区的状态 查看文件差异当我们把暂存区文件撤销回到工作区, 则工作区 暂存区差异与 工作区 版本库差异相同, 暂存区 版本库无差异 1234567891011121314151617181920212226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diffdiff --git a/test.txt b/test.txtindex 2f59be1..7d6ebc9 100644--- a/test.txt+++ b/test.txt@@ -1 +1,2 @@ this is a test txtfile+add a line to test recall 226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff headdiff --git a/test.txt b/test.txtindex 2f59be1..7d6ebc9 100644--- a/test.txt+++ b/test.txt@@ -1 +1,2 @@ this is a test txtfile+add a line to test recall 226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff --cached 查看文件内容12this is a test textadd a new line2 说明,将文件从暂存区撤回工作区,不会撤销此前我们的修改 从暂存区撤销后, 再撤销此前工作区的修改当我们从暂存区撤回文件后, 还可再撤销其在工作区的上次修改 此时应使用工作区撤销修改命令git restore filename,如下: 1$ git restore test.txt 查看文件内容; 1this is a test text 从版本库撤销准备 我们上面将test.txt文件恢复到了 : 1this is a test txtfile 我们为其标定版本 : 1git tag v1.0 查看log 12345678$ git log --pretty=oneline --abbrev-commit8244163 (HEAD -&gt; master, tag: v1.0) commit to test recall from commitabfb3b5 commit this testfile to comiit hist3699296 aa1dd8abb aa543a126 aa7abf4b6 add a new line by vim 可见当前版本(最新一次commit)被标定为了v1.0, 后面紧跟着最新一次commit的info 此时的版本v1.0对应test.txt文件内容为this is a test txtfile 我们对其做出如下修改 : 12this is a test txtfileadd a line by v2.0 提交到版本库 : 123$ git add . &amp;&amp; git commit -m &quot;commit to release v2.0&quot;[master be390c4] commit to release v2.0 1 file changed, 1 insertion(+), 1 deletion(-) 此处我们使用&amp;&amp;符号连接多个命令 为此次commit标定版本v2.0 : 1226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git tag v2.0 查看当前版本信息 : 123456789$ git log --pretty=oneline --abbrev-commitbe390c4 (HEAD -&gt; master, tag: v2.0) commit to release v2.08244163 (tag: v1.0) commit to test recall from commitabfb3b5 commit this testfile to comiit hist3699296 aa1dd8abb aa543a126 aa7abf4b6 add a new line by vim 可见上次commit信息commit to release v2.0出现, 且此时版本库为v2.0 至此, 我们为修改前的文件标定了v1.0, 为修改后的文件标定了v2.0 查看工作区状态123$ git statusOn branch masternothing to commit, working tree clean 查看文件差异当我将文件提交到版本库后, 各区内文件皆无差异 : 12345678926676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff head26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff --cached test.txt 此时文件内容12this is a test txtfileadd a line by v2.0 版本回退版本回退指的是将当前版本回退到之前的版本 使用commit id 或 tag进行版本回退基本命令为git reset --hard &lt;id/tag&gt; : 1. 使用tag进行回退 : 12326676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git reset --hard v1.0HEAD is now at 8244163 commit to test recall from commit 此时的文件内容 1this is a test txtfile可见版本回退之后, 文件也回到了该版本 2. 使用commit id回退 : 我们从上面的log中复制七位数的commit id 7abf4b6: 12326676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git reset --hard 7abf4b6HEAD is now at 7abf4b6 add a new line by vim 此时文件内容 : 1this is a test line 这是文件创建时, 使用vim添加的测试行 因此, 在每次commit时详细写好info大有用处 版本回退之后的版本信息log12345678$ git log --pretty=oneline --abbrev-commit7abf4b6 (HEAD -&gt; master) add a new line by vim00e7919 add a test.txt to repo40442a5 AA85f2fbb ADD T2.TXTbd8bfc5 add a line id = 3d5fe445 add a line id = 2fb84050 add a line id = 1 可见, 当我们回退版本之后, 普通log命令无法展示回退之前的信息 reflog展示详细log信息123456789101112$ git reflog --pretty=oneline --abbrev-commit7abf4b6 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 7abf4b68244163 (tag: v1.0) HEAD@&#123;1&#125;: reset: moving to v1.0be390c4 (tag: v2.0) HEAD@&#123;2&#125;: reset: moving to v2.0be390c4 (tag: v2.0) HEAD@&#123;3&#125;: commit: commit to release v2.08244163 (tag: v1.0) HEAD@&#123;4&#125;: reset: moving to 8244163199f71f HEAD@&#123;5&#125;: reset: moving to v1.08244163 (tag: v1.0) HEAD@&#123;6&#125;: commit: commit to test recall from commitabfb3b5 HEAD@&#123;7&#125;: commit: commit this testfile to comiit hist3699296 HEAD@&#123;8&#125;: commit: aa1dd8abb HEAD@&#123;9&#125;: commit: aa543a126 HEAD@&#123;10&#125;: commit: aa 我们使用reflog可以打印出历史版本中最远的版本记录 使用HEAD进行回退为方便演示, 我们将当前版本用tag回到v2.0时代 : 12345678926676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git reset --hard v2.0HEAD is now at be390c4 commit to release v2.026676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git log --pretty=oneline --abbrev-commitbe390c4 (HEAD -&gt; master, tag: v2.0) commit to release v2.08244163 (tag: v1.0) commit to test recall from commitabfb3b5 commit this testfile to comiit hist 此时的文件内容为 : 12this is a test txtfileadd a line by v2.0 git中HEAD指针指向当前版本(最新的commit id) HEAD^代表当前版本的上一个版本, HEAD^类推 我们使用HEAD来回退到v2.0的上一个版本(及v1.0) : 123456726676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git reset --hard HEAD^HEAD is now at 8244163 commit to test recall from commit26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git log --pretty=oneline --abbrev-commit8244163 (HEAD -&gt; master, tag: v1.0) commit to test recall from commit 可见当前版本回退到了v1.0 文件内容 : 1this is a test txtfile 文件也会回退到了v1.0","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-05-文件操作","slug":"git/git-05-文件操作","date":"2021-07-13T02:53:22.000Z","updated":"2021-07-20T13:16:31.186Z","comments":true,"path":"2021/07/13/git/git-05-文件操作/","link":"","permalink":"http://example.com/2021/07/13/git/git-05-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"一些关于文件的基础操作","text":"一些关于文件的基础操作 新建新建文件夹使用命令mkdir &lt;name&gt;创建一个新的文件夹 1$ mkdir testfolder 查看当前文件夹下是否新建了testfolder 12$ lstestfolder/ 可见新文件夹创建成功 新建文件使用命令 touch &lt;name&gt; 创建一个新文件1$ touch test.txt 查看文件 12$ lstest.txt testfolder/ 可见文件已创建成功 工作区状态1234567$ git statusOn branch masterUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) test.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 可见git已经检测我们新建了文件,但并不会识别文件夹并且git提示我们使用add命令将文件添加到暂存区 将文件添加到版本库先使用add将文件添加到暂存区 1git add test.txt 在使用commit将文件提交到版本库 1git commit -m &quot;info&quot; 当然你也可以使用&amp;&amp;将多个git命令链接起来 1234$ git add test.txt &amp;&amp; git commit -m &quot;add a test.txt to repo&quot;[master 00e7919] add a test.txt to repo 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 test.txt 至此,我们新建的文件便被添加到了版本库 使用 vim 对文件进行简单编辑进入vim编辑器使用vim name,利用vim编辑器打开name文件 1$ vim test.txt 回车后,我们便进入了vim编辑器,如下 123456789101112131415161718192021222324~~~~~~~~~~~~~~~~~~~~~test.txt [unix] (17:00 12/07/2021) 0,0-1 All&quot;test.txt&quot; 0L, 0B 倒数第一行显示当前文件名 `line``数 以及文件大小 倒数第二行显示文件相关信息利用vim进行编辑我们按下insert键进入insert模式,即文本编辑模式,此时最后一行变为-- INSERT -- ,表明我们正在进行文本编辑 我们键入this is a test line,完成对文本的编辑 vim的退出 首先按下(或按住)esc,此时最后一行变为空 再输入:(shift + ;和我们平时输入:一样), 此时最后一行出现了: 再输入wq, 此时最后一行变为:wq 最后回车,便完成了对文件的保存退出 检查文本的编辑结果再次使用vim name进入vim编辑器 1$ vim test.txt 123456789101112131415161718192021222324this is a test line~~~~~~~~~~~~~~~~~~~~~test.txt [unix] (17:12 12/07/2021) 1,19 All&quot;test.txt&quot; [unix] 1L, 20B 可见最后一行的文本信息发生了变化,文本也被保存在了文件内 提交修改对文件编辑后,记得提交我们满意文件版本 12345$ git add . &amp;&amp; git commit -m &quot;add a new line by vim&quot;warning: LF will be replaced by CRLF in test.txt.The file will have its original line endings in your working directory[master 7abf4b6] add a new line by vim 1 file changed, 1 insertion(+) git 删除文件git rm最简单的将文件从追踪中删除并最终从仓库中删除的方法是git rm 12$ git rm t2.txtrm &#x27;t2.txt&#x27; 运行本命令后,t2.txt文件将会被从本地文件夹删除,并且删除的操作信息也会被添加到暂存区 12345$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) deleted: t2.txt 此时,工作区和版本库中的文件便不一致,如果确定要将此文件删除,则进行commit操作,将此次修改提交 1234$ git add . &amp;&amp; git commit -m&quot;remove a file&quot;[master 440e71c] remove a file 1 file changed, 2 deletions(-) delete mode 100644 test.tst 此时工作区状态重回clean 123$ git statusOn branch masternothing to commit, working tree clean 此时版本库中的文件也已经被删除 git 撤销删除演示之前让我们先创建一个演示文件t.txt 12345678910111213141516# 创建文件26676@DESKTOP-JCSGJPO MINGW64 /a/git/gitlearn (master)$ touch t.txt# 查看当前目录下的文件26676@DESKTOP-JCSGJPO MINGW64 /a/git/gitlearn (master)$ lst.txt# 将该文件添加到暂存区26676@DESKTOP-JCSGJPO MINGW64 /a/git/gitlearn (master)$ git add t.txt# 将该修改提交到repo26676@DESKTOP-JCSGJPO MINGW64 /a/git/gitlearn (master)$ git commit -m &quot;add t.txt to the repo&quot;[master 2e7ebbb] add t.txt to the repo 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 t.txt 并在其内部做出一下修改: 1add a line 1 commit并标注commit -m为 : add a line id = 1 类似添加add a line 2 以及 add a line 3, 每次提交都应标注-m 查看当前文件的修改日志 123456789101112131415161718$ git log t.txtcommit bd8bfc562d20853126dc73b5bd3adad88dd67ca7 (HEAD -&gt; master)Author: MarkLilyC &lt;2667602812@qq.com&gt;Date: Mon Jul 12 16:33:12 2021 +0800 add a line id = 3commit d5fe44542872c4cebe7a21ff0927d65cbdfe7427Author: MarkLilyC &lt;2667602812@qq.com&gt;Date: Mon Jul 12 16:32:56 2021 +0800 add a line id = 2commit fb840504b7cfd1096de4e2a1bd858b2cbfd63407Author: MarkLilyC &lt;2667602812@qq.com&gt;Date: Mon Jul 12 16:30:56 2021 +0800 add a line id = 1 可以见到我们所标注的commit信息 将该文件从本地删除1git rm t.txt 查看本地文件夹内是否存在文件 12326676@DESKTOP-JCSGJPO MINGW64 /a/git/gitlearn (master)$ ls 可见本地已经删除了文件 工作区状态 12345$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) deleted: t.txt 此时我们尚未将删除操作commit到版本库因从git提示可以看出,此次rm被自动提交到了暂存区,我们可以使用restore --staged将此次删除从暂存区撤销 在commit删除前,撤销删除如上文所言,我们尝试使用restore --staged从暂存区撤销删除 1234567891011121314151617181920## ``git``重命名文件#### 当直接在工作区(文件夹内)重命名文件时,``git``会执行两个操作;* 1. 将源文件从工作区删除 * 2. 将新文件添加到工作区```git$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) deleted: t2.txtChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) deleted: text1.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) text1_rename.txt 这样做的缺点是会破坏掉文件的历史版本记录,此后你便无法查看此文件在重命名前的历史记录 git mv命令则可以解决这个历史记录断链的问题1$ git mv text1.txt test1_rename.txt mv命令相当于move,此处重命名文件也就是text1.txt被移动重命名为text1_rename.txt 此时检查工作区状态,mv命令会被解析为rename 12345$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) renamed: test1_rename.txt -&gt; text1_rename.txt git 移动文件同样使用mv命令,当在移动后文件名前加上移动后的文件夹路径,即可完成对文件的移动 1$ git mv test.txt move/test1.txt 查看工作区状态” 12345$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) renamed: test.txt -&gt; move/test1.txt 可以看见移动文件操作同样属于rename操作 移动前请记得创建目标文件夹 查看目标文件夹: 1234567891026676@DESKTOP-KEJKGL7 MINGW64 /a/git/gitlearn (master)$ lsmove/26676@DESKTOP-KEJKGL7 MINGW64 /a/git/gitlearn (master)$ cd move26676@DESKTOP-KEJKGL7 MINGW64 /a/git/gitlearn/move (master)$ lstest1.txt git log 查看日志使用git log -- &lt;name&gt;查看指定文件的修改日志 123456789101112$ git log -- test.txtcommit 83777091dcd8754184c0cfa69e1f4d2e112813adAuthor: MarkLilyC &lt;2667602812@qq.com&gt;Date: Mon Jul 12 16:08:25 2021 +0800 renamecommit 8b0aa8b25a3d1d9d5528731f32e12437037c7454Author: MarkLilyC &lt;2667602812@qq.com&gt;Date: Mon Jul 12 16:06:00 2021 +0800 aa 使用--pretty=oneline --abbrev-commit简化日志信息``123456789$ git log --pretty=oneline --abbrev-commit -- test.txt8377709 rename8b0aa8b aa199f71f (tag: v1.0, dev) AA9ee99cc aa544892d AA372904b aab4ff36e aa518f7b2 cj","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-04-标签","slug":"git/git-04-标签","date":"2021-07-13T01:53:22.000Z","updated":"2021-07-17T02:19:42.940Z","comments":true,"path":"2021/07/13/git/git-04-标签/","link":"","permalink":"http://example.com/2021/07/13/git/git-04-%E6%A0%87%E7%AD%BE/","excerpt":"我们每次提交commit都会生成对应的commit id方便我们进行回溯 ，同样我们也可以手动为每个版本标定标签","text":"我们每次提交commit都会生成对应的commit id方便我们进行回溯 ，同样我们也可以手动为每个版本标定标签 git tag &lt;name&gt; - 创建标签git tag的基本语法为 ： 1git tag &lt;name&gt; 此处我们假定对master进行版本标记 ， 进入master分支 ： 12326676@DESKTOP-JCSGJPO MINGW64 /a/git/gitlearn (master)$ git checkout masterSwitched to branch &#x27;master&#x27; 使用命令进行版本标记 ： 1226676@DESKTOP-JCSGJPO MINGW64 /a/git/gitlearn (master)$ git tag v1.0 git tag - 查看标签git tag - 查看所有标签记录使用git tag查看当前分支标签记录 : 123$ git tagv1.0v2.0 但是此记录不是按照添加时间记录, 而是按照字母排序 git show &lt;tagname&gt; - 查看详细信息使用git show &lt;tagname&gt;查看各标签详细信息 : 1234567891011121314151617$ git show v1.0commit 199f71f3a9a825671b44a0790b619c531902a271 (tag: v1.0)Author: MarkLilyC &lt;2667602812@qq.com&gt;Date: Mon Jul 12 14:30:56 2021 +0800 AAdiff --git a/test.txt b/test.txtindex 1b63dd4..136aecc 100644--- a/test.txt+++ b/test.txt@@ -1,3 +1,5 @@ public line... -------------- add in A+--------------+add in B 追加标签每次git tag &lt;name&gt;都是默认添加在最新的commit的版本 当我们某次commit后忘记添加标签,可以向该版本追加标签 我们先随意进行几次提交 git log - 查看日志1234567891011121314151617181920$ git log --pretty=oneline --abbrev-commit8244163 (HEAD -&gt; master, tag: v2.0) commit to test recall from commitabfb3b5 commit this testfile to comiit hist3699296 aa1dd8abb aa543a126 aa7abf4b6 add a new line by vim00e7919 add a test.txt to repo40442a5 AA85f2fbb ADD T2.TXTbd8bfc5 add a line id = 3d5fe445 add a line id = 2fb84050 add a line id = 12e7ebbb add t.txt to the repo440e71c remove a file1e71bf1 rename8377709 rename8b0aa8b aa199f71f (tag: v1.0) AA0bbb931 aa 追加标签使用git tag &lt;name&gt; commit_id 对指定commit进行标签 : 1226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git tag v1.5 1dd8abb 1234$ git tagv1.0v1.5v2.0 可见新标签已被添加 删除标签使用git tag -d &lt;name&gt;删除指定标签 : 1234567826676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git tag -d v1.5Deleted tag &#x27;v1.5&#x27; (was 1dd8abb)26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git tagv1.0v2.0 可见v1.5被成功删除","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-03-分区及工作流程","slug":"git/git-03-分区及工作流程","date":"2021-07-13T00:53:22.000Z","updated":"2021-07-17T02:08:36.385Z","comments":true,"path":"2021/07/13/git/git-03-分区及工作流程/","link":"","permalink":"http://example.com/2021/07/13/git/git-03-%E5%88%86%E5%8C%BA%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/","excerpt":"git本地数据管理存在三个分区 : 工作区 暂存区 版本库","text":"git本地数据管理存在三个分区 : 工作区 暂存区 版本库 git 分区分区简介git的本地数据管理有以下三个分区 : 工作区-working directory : 可理解为本地文件夹以及对文件夹内部文件的操作, 我们在win10系统内日常对文件的新建 编辑 删除等操作都属于在工作区内的修改 暂存区-stage : 数据暂时存放的地方, 我们在工作区对文件做出修改后, 文件的修改信息一般需要提交存储到暂存区 版本库-commit History : 我们将暂存区内文件的修改信息提交后, 文件的最终修改版本存放的位置成为版本库 数据传递三个分区之间的数据传递 : 1. 在工作区对文件进行修改(本地文件) ↓ git add &lt;name&gt;-将工作区修改提交到暂存区 2. 文件被暂存到暂存区 ↓ git git commit &lt;name&gt;-将暂存区数据到版本库 3. 修改后的文件被存放到版本库 基本命令 git status-查看工作区状态 git add &lt;name&gt;-将工作区修改提交到暂存区 git commit &lt;name&gt;-将暂存区数据到版本库 git diff &lt;name&gt;-查看工作区与暂存区差异 git diff head &lt;name&gt;-查看工作区与版本库差异 git diff head --cached &lt;name&gt;-查看暂存区与版本库差异 working directory - 工作区 我们可以把工作区理解为本地文件夹 当我们直接在文件夹内对文件进行修改(新建 删除 编辑等操作) 或是在git bash内进行对文件修改 都属于工作区内的工作 为方便演示, 我们利用git bash进入上一节建立的/a/Git/gitlearn (master)中 ，同时也在windows文件夹内进行观察 ls12326676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ lstest.txt 当前位置仅存在我们上一节创建的示例test.txt git status123$ git statusOn branch masternothing to commit, working tree clean git提示 ： On branch master-表明当前工作区处于分支master (稍后将详细介绍) nothing to commit, working tree clean-表明当前工作区并未有任何对文件的修改 (因为上一节我们创建test.txt后已经进行了相关add与commit处理) 此时我们的工作区处于clean状态, 代表着无事发生 接下来, 我们对工作区进行相关演示 工作区内修改我们先利用vim test.txt进入该文件, 检查文本内容 : 1vim test.txt 可见文本为空(因为我们创建时, 并未做出任何修改), 如下 : 123456789101112131415161718192021222324~~~~~~~~~~~~~~~~~~~~~test.txt [unix] (13:06 13/07/2021) 1,23 All&quot;test.txt&quot; [unix] 0L, 0B 利用vim编辑器, 我们对test.txt文件做出以下修改 : 123456789101112131415161718192021222324this is a test txtfile~~~~~~~~~~~~~~~~~~~~~test.txt [unix] (13:06 13/07/2021) 1,23 All-- INSERT -- 此处的文件编辑也可使用记事本 status 更新保存退出后, 使用git status查看工作区状态 : 12345678$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git提示 ： On branch master-处于master分支 Changes not staged for commit-存在一些尚未提交到暂存区以待进一步提交commit的修改 : use &quot;git add &lt;file&gt;...&quot;-使用git add将修改提交到暂存区以待进一步commit use &quot;git restore &lt;file&gt;...&quot;-使用git restore撤销在工作区内的修改 modified: test.txt - 表明我们对test.txt被我们modified(修改) 至此, 我们可以看出: git能够检测到对仓库内的本地文件进行修改 此时 ，我们不对文件进行任何提交 ，仅仅将其保留在本地而此时, 暂存区以及版本库中存在的test.txt是我们在初始化仓库时提交的空文件接下来, 我们详细观察各区内文件的差异 各区内文件差异git diff - 工作区与暂存区123456789$ git diffwarning: LF will be replaced by CRLF in test.txt.The file will have its original line endings in your working directorydiff --git a/test.txt b/test.txtindex e69de29..2f59be1 100644--- a/test.txt+++ b/test.txt@@ -0,0 +1 @@+this is a test txtfile git提示 ： warning-提示我们git会将LF 换行符号转换为CRLF ，这并不影响 diff --git a/test.txt b/test.txt-查看test.txt的文件差异 我们关注最后一行 : +this is a test txtfile-表明我们添加了一行 由于我们并未将本地的修改提交到暂存区 ，因此暂存区内的test.txt依然是空文件 ，因此在对比两者文件差异时 ，自然会显示我们在工作区内文件新增一行 git diff head - 工作区与版本库123456789$ git diff headwarning: LF will be replaced by CRLF in test.txt.The file will have its original line endings in your working directorydiff --git a/test.txt b/test.txtindex e69de29..2f59be1 100644--- a/test.txt+++ b/test.txt@@ -0,0 +1 @@+this is a test txtfile 由于版本库和暂存区内的test.txt都是空文件 ，因此对比工作区与暂存区的差异与工作区与版本库的差异 ，二者几乎一致 3. git diff -cached 1226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff --cached test.txt 版本库和暂存区都是空文件 ，自然不会有任何差异 查看本地文件我们暂时不管这些修改, 用记事本打开test.txt, 可以发现我们在vim内做出的修改呈现在了记事本 其他修改(如 新建文件 删除文件与此类似, 只是提示信息不同) git add - 工作区→暂存区git add &lt;name&gt;我们使用git add &lt;name&gt;将上面做出的修改提交到暂存库 提交前, 查看工作区状态, 提示我们有未提交修改, 如下 : 12345678$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 提交 ： 123$ git add test.txtwarning: LF will be replaced by CRLF in test.txt.The file will have its original line endings in your working directory 当我们有大量文件需要提交时, 可使用.代替文件名. 但应注意的是add与 .中间有空格 warning信息指git将回车换行转为CRLF, 可忽略 status更新12345$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: test.txt git提示中 : use &quot;git add &lt;file&gt;...&quot;消失, 表明我们已经将文件修改信息提交到了暂存区stage use &quot;git restore --staged &lt;file&gt;...&quot;-使用git restore --staged撤销此次提交 使用git add后, git提示事项中关于使用git add的提示消失 ，这表明我们成功使用了该命令将文件提交到了暂存区 暂存区查看文件差异分析 ：由于我们已经将文件提交到了暂存区 ，因此暂存区内文件与工作区一致 ，暂存区文件与版本库不一致 ： git diff12326676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff 如我们分析 ：工作区与暂存区无差异 2. git diff head 1234567$ git diff headdiff --git a/test.txt b/test.txtindex e69de29..2f59be1 100644--- a/test.txt+++ b/test.txt@@ -0,0 +1 @@+this is a test txtfile 工作区与版本库存在差异 3. git diff --cached 1234567$ git diff --cached test.txtdiff --git a/test.txt b/test.txtindex e69de29..2f59be1 100644--- a/test.txt+++ b/test.txt@@ -0,0 +1 @@+this is a test txtfile 暂存区与版本库存在差异 git commit - 暂存区→版本库commit 语法规则1git commit &lt;name&gt; -m &quot;info&quot; &lt;name&gt;-文件夹名, 为可选项 -m &quot;info&quot;-commit信息为必填, 在info处填入commit信息 使用commit12345$ git commit test.txt -m &quot;commit this testfile to comiit hist&quot;warning: LF will be replaced by CRLF in test.txt.The file will have its original line endings in your working directory[master abfb3b5] commit this testfile to comiit hist 1 file changed, 1 insertion(+) status更新1234$ git statusOn branch masternothing to commit, working tree clean git提示中clean, 表明此时工作区修改信息已经完全提交 版本库查看文件差异分析 ： 由于我们已经将文件提交到了版本库, 故工作区 暂存区差异 工作区 版本库差异 与 暂存区 版本库差异皆无差异 ： 1234567826676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff head26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff --cached test.txt 修改提交当我们在将文件提交到仓库后又发现了其他微小错误,我们大可以在本地修改源文件后再次进行提交 但是也可以重写最近一次的提交,新的提交会覆盖掉错误的版本 语法为：git commit --amend&quot;commit information commit后的amend标志告诉git此次提交将会覆盖掉上次提交的内容,上次提交也不会在日志信息汇中出现 永远不要修改非最新提交，因为其他项目团队成员或其他分支有可能是基于该提交的版本。在修改提交之后，他们的版本将会失去了参考，版本控制很难从中恢复。","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-02-初始化本地仓库","slug":"git/git-02-初始化本地仓库","date":"2021-07-12T15:18:09.000Z","updated":"2021-07-16T15:44:56.164Z","comments":true,"path":"2021/07/12/git/git-02-初始化本地仓库/","link":"","permalink":"http://example.com/2021/07/12/git/git-02-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/","excerpt":"创建一个本地文件夹用以初始化本地仓库， 进行本地数据的管理","text":"创建一个本地文件夹用以初始化本地仓库， 进行本地数据的管理 在c盘创建一个Git文件夹,但此文件夹不是必要的在Git文件夹内创建一个用于学习git的文件夹gitlearn git init - 初始化仓库使用命令git init初始化仓库 1$ git init 随后便可以看见初始化成功的确认信息 12$ git initInitialized empty Git repository in A:/Git/gitlearn/.git/ 创建好第一个仓库后, 我们简单进行一些本地的数据管理演示 git status - 工作区状态status - 工作区状态我们在本地对文件进行修改后, git会检测到这些修改, 并提供相应的后续处理建议 以上操作记录即操作建议, 构成了工作区状态–status git status - 查看状态使用 git status 查看当前仓库信息 123456$ git statusOn branch masterNo commits yetnothing to commit (create/copy files and use &quot;git add&quot; to track) 可见此时仓库是空的,当前branch为master, 没有任何commit status - 更新新建文件我们尝试向仓库添加一个文本文件text.txt ： 使用 touch filename创建一个文件 使用 ls查看当前路径下的所有文件12345626676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ touch test.txt26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ lstest.txt 此处, 我们也可在文件夹内\"新建文件夹\" 查看新状态我们再次使用git status查看信息,可得 ： 1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) text1.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 显示我们新建了一个text1.txt文件,但是该文件未在git的追踪目录内 如果我们不添加和提交此文件,git便不会跟踪此文件 git add - 提交暂存区对于我们新建的文件test.txt, 我们想让git追踪其版本更迭, 此时我们应如上面git建议所 ：使用git add命令将其提交到暂存区 git add - 提交暂存区使用git add &lt;name&gt;命令将该文件添加到staging区域(即暂存区) ， 可得 ： 123$ git add text1.txtwarning: LF will be replaced by CRLF in text1.txt.The file will have its original line endings in your working directory 报错提示:The file will have its original line endings in your working directory 是因为git默认将文本中的回车换行统一为CRLF,不影响文本的实际使用 git status - 查看状态12345678$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: text1.txt 此时的提示信息更新为 ：git rm --cached &lt;file&gt;... ，提示我们使用rm来将文件从暂存区撤回git status - 工作区状态 git commit - 提交版本库使用git commit -m &quot;info&quot;将暂存区的文件提交到仓库中 ： 1234$ git commit -m &quot;the first commit. add text1.txt to the repository&quot;[master (root-commit) 21dced3] the first commit. add text1.txt to the repository 1 file changed, 1 insertion(+) create mode 100644 text1.txt -m后的信息为此次commit的信息 此时再次检查工作区的状态,可以看见干净的工作树 123$ git statusOn branch masternothing to commit, working tree clean git log - 日志信息使用git log获得历史提交记录 ： 123456$ git logcommit 21dced3ee6053a17e148ef75cd2d35863155f4a9 (HEAD -&gt; master)Author: MarkLilyC &lt;2667602812@qq.com&gt;Date: Sun Jul 11 16:50:18 2021 +0800 the first commit. add text1.txt to the repository 可见我们设置的提交信息被打印了出来 简化日志信息使用命令git log --pretty=onelin --abbrev-commit 12345678910111213141516171819202122232425$ git log --pretty=oneline --abbrev-commit8244163 (HEAD -&gt; master, tag: v2.0) commit to test recall from commitabfb3b5 commit this testfile to comiit hist3699296 aa1dd8abb aa543a126 aa7abf4b6 add a new line by vim00e7919 add a test.txt to repo40442a5 AA85f2fbb ADD T2.TXTbd8bfc5 add a line id = 3d5fe445 add a line id = 2fb84050 add a line id = 12e7ebbb add t.txt to the repo440e71c remove a file1e71bf1 rename8377709 rename8b0aa8b aa199f71f (tag: v1.0) AA0bbb931 aad219e28 aa08926e9 aaa638d98 aa9ee99cc aa 按下q退出 以上便是使用git init进行初始化的步骤, 以及一些简单的命令操作","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-01-基本命令","slug":"git/git-01-基本命令","date":"2021-07-12T14:18:09.000Z","updated":"2021-07-17T02:46:21.028Z","comments":true,"path":"2021/07/12/git/git-01-基本命令/","link":"","permalink":"http://example.com/2021/07/12/git/git-01-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"windows系统进入git bash 后有大量的命令来解放鼠标操作 以下将介绍部分常用命令","text":"windows系统进入git bash 后有大量的命令来解放鼠标操作 以下将介绍部分常用命令 我们在随意位置打开 git bash pwd–查看当前位置使用 pwd 查看当前窗口处在位置 : 12326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ pwd/a/testfolder git 显示我当前的位置为 `/a/testfolder 即表明我当前处于 a 盘内 testfolder 文件夹内 我们也可以直观通过26676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder最后的文件夹位置查看 以下示例, 我们皆通过此行信息判定当前位置, 不再刻意使用pwd ls–查看文件(夹)使用 ls 查看当前位置所有的文件(夹) : 12326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ lsfolder1/ folder2/ git-分支合并.md git-工作流程.md git-文件操作.md 可见当前 /a/testfolder 文件夹内有两个文件夹 folder1/ 与 folder2 , 以及三个文件 git-分支合并.md 等 cd–进入文件夹单次进入使用 cd &lt;foldernam&gt; 进入目标文件夹 1234526676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ cd folder126676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder1$ 一般为确认当前位置存在哪些文件夹, 我们先使用 ls 查看当前位置存在的文件夹 在git bash内的复制粘贴为 crtl + insert 与 shift + insert 在 ls 结果中复制粘贴想使用的路径, 再进行后续操作 多次进入我们也可以直接在 cd 后使用我们想要去的最终路径 我们随意复制一个其他位置的路径, 如 : /e/pics/beatles 1234526676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder1$ cd /e/pics/beatles26676@DESKTOP-KEJKGL7 MINGW64 /e/pics/beatles$ 可以发现 cd 命令可以直接定位到目标路径, 不论该路径是否与我们当前位置有从属关系 cd ../退出文件夹使用cd ../退出当前文件夹, 返回上一级1234526676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder1$ cd ../26676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ 如上代码, 我们使用cd ../ 从 /a/testfolder/folder1 回退到了 /a/testfolder 组合使用cd ../回退多重文件夹为方便演示, 我们再次进入 /a/testfolder/folder1 : 1234526676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ cd folder126676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder1$ 对于前面使用过的代码, 比如此处的 `cd folder1 , 我们可以使用键盘 ↑ ↓ 来浏览我们使用过的命令, 再回车进行使用 对于不小心输入错误的命令, 我们可以使用 crtl + c 来撤销此次命令, 开始下一次的命令输入 12326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ cd folder1\\&gt; ^C 如上, 在输入 folder1 后不小心输入\\ 并按下了回车, 此时我们使用 crtl + c 便失效了此次命令输入, 直接进行下次输入 接下来我们正式使用多个 ../ 组合完成多级文件夹的回退 12345626676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder1$ cd ../../../../26676@DESKTOP-KEJKGL7 MINGW64 /$ pwd/ 如上, 我们使用四个 ../ 组合完成了四次的回退, 最终回到了不属于任何特定盘的位置 此时使用 pwd , git 告诉我们此时处于 / 这么一个位置, 我们可以把这个位置想象成所有文件的终根目录,从这里我们可以直接进入任何盘 mkdir创建文件夹为了方便演示, 我们回到 /a/testfolder 文件夹下 查看当前位置的文件(夹) : 12326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ lsfolder1/ folder2/ git-分支合并.md git-工作流程.md git-文件操作.md 我们想要创建一个 folder3 , 则使用 mkdir &lt;foldername&gt; : 1226676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ mkdir folder3 查看当前文件: 12326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ lsfolder1/ folder2/ folder3/ git-分支合并.md git-工作流程.md git-文件操作.md 可见 folder3 被成功创建 touch创建文件我们 cd folder3 进入刚才创建的 folder3 , 并查看当前文件夹内有哪些文件(夹) : 12345626676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ cd folder326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ ls 可见当前文件夹内无任何文件(夹) 我们使用 touch &lt;filename&gt; 创建一个文件 : 12345626676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ touch test.txt26676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ lstest.txt 可见 test.txt 被成功创建 vim编辑器对文件进行简单编辑我们可以使用 vim 编辑器, 对刚才建立的 test.txt 文件进行简单编辑 : 使用 vim &lt;filename&gt; 命令来使用 vim 打开目标文件 : 1226676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ vim test.txt 回车后, 出现如下内容 : 123456789101112131415161718192021222324~~~~~~~~~~~~~~~~~~~~~test.txt [unix] (20:46 12/07/2021) 0,0-1 All&quot;test.txt&quot; 0L, 0B 每行前的 ~ 表明这是独立一行, 第一行无此符号 倒数第二行显示了一些此文件的基本信息, 如创建时间 尾行显示了此文件名 行数 大小 我们按下键盘 insert 键进入 insert 模式(即编辑模式), 此时最后一行变为 :-- INSERT -- 也只有在 insert 模式下我们才能做出修改 我们可以在光标闪烁处键入内容 : 1this is a test line vim 的退出 : 输入完毕后, 我们按下(或按住) esc 键, 此时屏幕进入闪烁状态, 且尾行的 insert 消失, 表明我们退出了编辑模式 此时我们输入一个 : , 即同时按下 shift + ; 键, 此时可以观察到尾行出现了我们刚才输入的 : , 且窗口停止闪烁 (此时若你是一直按着 esc , 那么我们可以松开 esc 键了) 输入 wq , 尾行变成了 :wq 最后按下回车键, 完成对文件的保存退出 我们完成测试编辑后, 使用 vim 或者记事本等编辑器打开该文件, 可见刚才的修改生效 : 123456789101112131415161718192021222324this is a test line~~~~~~~~~~~~~~~~~~~~~test.txt [unix] (20:58 12/07/2021) 1,18 All&quot;test.txt&quot; [unix] 1L, 21B vim 尾行显示了修改后的文件大小 rm删除文件使用 vim &lt;filename&gt; 删除文件 : 12345626676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ rm test.txt26676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ ls 可见 test.txt 被成功删除 此外还有很多与具体事务相关的命令, 我们后续详细介绍","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"python--函数","slug":"Python/basic/函数","date":"2021-07-10T04:21:57.000Z","updated":"2021-07-10T14:36:36.783Z","comments":true,"path":"2021/07/10/Python/basic/函数/","link":"","permalink":"http://example.com/2021/07/10/Python/basic/%E5%87%BD%E6%95%B0/","excerpt":"函数函数– 函数参数 参数类型","text":"函数函数– 函数参数 参数类型 默认参数 定义函数时设置默认值,则调用函数时不需要指定参数值12345&gt;&gt;&gt; def func(a = 1, b = 4):... return a * b...&gt;&gt;&gt; print(func())4 定义函数时设置默认值,调用函数指定他值,则他值覆盖默认值1234567&gt;&gt;&gt; def func(a = 1, b = 4):... return a * b...&gt;&gt;&gt; print(func())4&gt;&gt;&gt; print(func(2, 5))10 关键字参数(参数关键字) 调用函数传入参数时,若不指定各传入值对应参数名,则传入值会按照默认顺序(函数定义式中的参数顺序)进行参数赋值12345&gt;&gt;&gt; def func2(a, b, c, d):... return(a * 1000 + b * 100 + c * 10 + d)...&gt;&gt;&gt; print(func2(1,2,3,4))1234 调用函数传入参数时,指定参数关键字则不用在意参数传入顺序1234567&gt;&gt;&gt; def func2(a, b, c, d):... return(a * 1000 + b * 100 + c * 10 + d)...&gt;&gt;&gt; print(func2(1,2,3,4))1234&gt;&gt;&gt; print(func2(d=4, a=1, c=3, b=2))1234 任意参数1. 在任意参数前添加*标定此参数为任意参数 它将非关键字的参数作为元组传入函数内部1234567&gt;&gt;&gt; def func2(a, b, c, d):... return(a * 1000 + b * 100 + c * 10 + d)...&gt;&gt;&gt; print(func2(1,2,3,4))1234&gt;&gt;&gt; print(func2(d=4, a=1, c=3, b=2))1234 2. **kwargs 用以传递任意关键字参数(kew = ars) 将带传入参数及其关键字以&#39;&#39;键值对&#39;&#39;形式传入 传入参数及其关键字被转换为dict传入函数内部,通过关键字定位参数值123456789&gt;&gt;&gt; def func4(**kwargs):... print(kwargs.__class__)... for i in kwargs:... print(&#x27;this is &#x27; + str(i) + &#x27; and its arg = &#x27; +str(kwargs[i]))...&gt;&gt;&gt; func4(name = &#x27;markilily&#x27;,age = 120)&lt;class &#x27;dict&#x27;&gt;this is name and its arg = markililythis is age and its arg = 120","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--元组","slug":"Python/basic/元组","date":"2021-07-07T07:55:24.000Z","updated":"2021-07-10T14:34:58.036Z","comments":true,"path":"2021/07/07/Python/basic/元组/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E5%85%83%E7%BB%84/","excerpt":"列表与元组 当元素类型不一时使用元组,当类型一样则使用列表 [1] 元组遍历更快 使用元组元素(不可变)可作为字典的键值,而列表不可 元组保证了数据的安全","text":"列表与元组 当元素类型不一时使用元组,当类型一样则使用列表 [1] 元组遍历更快 使用元组元素(不可变)可作为字典的键值,而列表不可 元组保证了数据的安全 1 列表略 2 元组-tuple元组类似于列表,但区别在于元组中的元素是不可变的 2.1 创建一个元组1. 使用()创建一个元组,使用,间隔元素2. 类似于列表,元组中的元素可以是任何数据类型 123&gt;&gt;&gt; tuple1 = (&#x27;aa&#x27;, 1, [1,2,3])&gt;&gt;&gt; print(tuple1, tuple1.__class__)(&#x27;aa&#x27;, 1, [1, 2, 3]) &lt;class &#x27;tuple&#x27;&gt; 因为元组不能改变,所以创建伊始就应该指定正确的元素 3. 创建元组时只指明一个元素(dtype A),则该元组(你意图创建的)会被视为A的对象 123456789101112# case1&gt;&gt;&gt; a = (&#x27;aa&#x27;)&gt;&gt;&gt; print(a.__class__)&lt;class &#x27;str&#x27;&gt;# case2&gt;&gt;&gt; b = ([1,2,3])&gt;&gt;&gt; print(b.__class__)&lt;class &#x27;list&#x27;&gt;# case3&gt;&gt;&gt; c = (1)&gt;&gt;&gt; print(c.__class__)&lt;class &#x27;int&#x27;&gt; case1-3中意图创建元组a b c,但创建时指指定了一个内部元素param(dtype A),因此该元组被视为A类的一个对象 2.2 访问元组元素2.2.1 索引-index[index:int]使用索引操作符来访问元组中的元素1. 正索引 : 0-len(tuple)-1 123&gt;&gt;&gt; tuple1 = (&#x27;aa&#x27;, 1, [1,2,3])&gt;&gt;&gt; print(tuple1[2])[1, 2, 3] 2. 负索引 2.2.2 切片:使用切片操作符 123&gt;&gt;&gt; tuple1 = (&#x27;aa&#x27;, 1, [1,2,3])&gt;&gt;&gt; print(tuple1[1:])(1, [1, 2, 3]) 方法1. enumerate(): 将元组内所有对象及其索引枚举,以元组的形式返回 12&gt;&gt;&gt; print(enumerate(tuple1).__class__)&lt;class &#x27;enumerate&#x27;&gt; 2. tuple(): 将序列（元组，字符串，字典）转换为元组 1234&gt;&gt;&gt; list1 = [1,2,&#x27;aa&#x27;,(1,2,3)]&gt;&gt;&gt; tp1 = tuple(list1)&gt;&gt;&gt; print(list1.__class__, tp1.__class__)&lt;class &#x27;list&#x27;&gt; &lt;class &#x27;tuple&#x27;&gt; 3. sorted: 返回一个排序元组 123&gt;&gt;&gt; tuplle1 = (2,2,3,0)&gt;&gt;&gt; print(sorted(tuplle1))[0, 2, 2, 3] 参考参考资料1 ↩","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--命名空间","slug":"Python/basic/命名空间","date":"2021-07-07T07:43:24.000Z","updated":"2021-07-10T14:36:48.586Z","comments":true,"path":"2021/07/07/Python/basic/命名空间/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","excerpt":"命名空间及作用域1.命名空间1.1 命名空间（Namespace）1. 是从名称到对象的映射，一般通过字典实现2. 类似于c++","text":"命名空间及作用域1.命名空间1.1 命名空间（Namespace）1. 是从名称到对象的映射，一般通过字典实现2. 类似于c++ 1using namespace std 1.2 命名空间主要为了避免对象名称冲突1. 各个命名空间之间相互独立2. 命名空间内部不能有同名称对象3. 各个命名空间之间可以有相同名称对象 123# 如计算机内部文件夹之间的关系： * 单个文件夹内部不能有同名称元素 * 不同文件夹之间可以同名称元素 1.3 python一般有三种命名空间：内置-built in 局部(本地)-local 全局-global1.3.1 局部1. 局部空间包含:函数中定义的名称,记录了函数的变量,包括函数的参数与局部变量 此局部指的是此作用域,及其内部包含的对象 名称 2. locals():返回当前位置的全部局部变量 当前位置指的是当前locals()函数被调用的位置 全局内使用locals():所有有实例的函数 方法 lambda函式以及实现了__call__的,都会返回true12&gt;&gt;&gt; print(locals())&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;len&#x27;: &lt;function len at 0x00000186888145E8&gt;&#125; 此时的局部空间等于全局空间 函数内部使用locals():返回此函数空间内的所有名称及对象123456&gt;&gt;&gt; def len(param):... in_param = 2... print(locals())...&gt;&gt;&gt; len(4)&#123;&#x27;param&#x27;: 4, &#x27;in_param&#x27;: 2&#125; 循环内使用locals(): 12345&gt;&gt;&gt; for i in [1,2]:... print(locals())...&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;i&#x27;: 1&#125;&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;i&#x27;: 2&#125; 证明for循环不算一个单独的作用域 1.3.2 全局1. 全局空间包含:模块中定义的名称,记录了模块的变量,包括函数 类 导入模块 可理解为此.py文件所代表的空间 2. globals():返回当前全局空间内的名称及对象 全局内使用globals():12&gt;&gt;&gt; print(globals())&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;i&#x27;: 2&#125; 全局命名空间里包括了整个模块内的命名名称，比如变量 x y 函数名,而且还包括了一些内置的变量命名，比如 __name__ __file__等等。 全局空间与全局使用局部空间相同:123456&gt;&gt;&gt; if locals() == globals():... print(&#x27;yes&#x27;)... else:... print(&#x27;no&#x27;)...yes 1.3.3 内置1. 内置空间包含:python语言的内置名称,如函数名abs char等1.4 各空间关系1. 命名空间使用顺序:局部-&gt;全局-&gt;内置 这样可以完成对全局 内置函数的’’改写’’:12345&gt;&gt;&gt; def len(param):... print(param)...&gt;&gt;&gt; len([1,2,3,4])[1, 2, 3, 4] python内置此方法的输出为元素长度:12&gt;&gt;&gt; print(len([1,2,3,4]))[1, 2, 3, 4] 当无法找到此名称的对象时,则抛出异常命名空间的生命周期命名空间的声明周期却决与该变量的作用域,对象执行完成,则该命名空间的生命周期结束2. 作用域2.1 作用域1. 作用域:访问某变量 对象的区域 每个对象都存在特定的作用域中 作用时段中 当前程序未执行到该作用域,则某些只存在于该作用域的对象则不能被访问 或者说,只有被赋值且未该赋值区域未完成其全部功能时,该对象才能被访问 简单来说就是:该对象在未赋值时,不能被访问;使用结束跳出该域后也不能访问 2.2 作用域分类2.2.1 L-local 局部作用域2.2.2 E-encloing scope 闭包函数作用域,嵌套函数(A(B(var c)))中var c所在作用域2.2.3 G=global2.2.4 B-built in1. 内置作用域的实现是通过builtin标准模块实现 但是此变量名本身并未放入内置作用域,需要导入模块才能使用2. builtin 12&gt;&gt;&gt; import builtins&gt;&gt;&gt; dir(builtins) 2.3 规则1. 当在函数中引用一个变量的时候，以上的作用域顺序也是 Python 搜索的一个顺序 L-&gt;E-G-B，首先尝试局部作用域，没找到的话，继续搜索闭包函数作用域，然后再是全局作用域和内置作用域。2. Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域 其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问(如1.3.1.2) 如:12345&gt;&gt;&gt; if True:... testStr = &#x27;this is a testline to test if this is a new region&#x27;...&gt;&gt;&gt; print(testStr)this is a testline to test if this is a new region","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--集合","slug":"Python/basic/集合","date":"2021-07-07T07:40:24.000Z","updated":"2021-07-10T14:36:39.371Z","comments":true,"path":"2021/07/07/Python/basic/集合/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E9%9B%86%E5%90%88/","excerpt":"集合-set集合的基本性质:1. 集合包含了不重复且无序的元素2. 集合是可变数据类型","text":"集合-set集合的基本性质:1. 集合包含了不重复且无序的元素2. 集合是可变数据类型 但是其内部元素必须是不可变数据类型,即元组可以作为其元素,但是列表 集合 字典不能作为其元素 1234&gt;&gt;&gt; c = &#123;1,2,3,[1,2]&#125;Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: &#x27;list&#x27; 1. 创建集合 使用&#123;&#125;创建集合,内部元素使用,分隔 使用python内置函数set()1234&gt;&gt;&gt; a = &#123;1,2,3,tuplle1&#125;&gt;&gt;&gt; b = set([1,3,&#x27;SS&#x27;,tuplle1])&gt;&gt;&gt; print(a.__class__, b.__class__)&lt;class &#x27;set&#x27;&gt; &lt;class &#x27;set&#x27;&gt; 2. 修改集合 不能通过索引 切片操作来访问其中的元素,因为集合是无序的2.1 添加元素1. add()方法添加单个元素2. update()方法添加多个元素12345678&gt;&gt;&gt; a = &#123;1,2,3,tuplle1&#125;&gt;&gt;&gt; a.add(&#x27;aa&#x27;)&gt;&gt;&gt; print(a)&gt;&gt;&gt; a = &#123;1,2,3&#125;&gt;&gt;&gt; a.update([2,4])&gt;&gt;&gt; print(a)&#123;1, 2, 3, 4&#125; 集合内不重复的性质会自动去掉update()参数中的重复元素 2.2 删除元素1. discard()2. remove()12345678910111213&gt;&gt;&gt; a.discard(2)&gt;&gt;&gt; print(a)&#123;1, 3, 4&#125;&gt;&gt;&gt; a.remove(1)&gt;&gt;&gt; print(a)&#123;3, 4&#125;&gt;&gt;&gt; a.discard(10)&gt;&gt;&gt; a.remove(11)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 11 二者差别在于,当被去除元素不存在时,discard不会报错,remove报错 3. pop():去掉任意一个元素 12&gt;&gt;&gt; a.pop()3 4. clear() 清空结合 1234567&gt;&gt;&gt; a.update([1,2,3,4,5,6,7,9])&gt;&gt;&gt; print(a)&#123;1, 2, 3, 4, 5, 6, 7, 9&#125;&gt;&gt;&gt; a.clear()&gt;&gt;&gt; print(a)set() 2.3 集合的逻辑操作1. &amp; / intersection – 交集 123456789&gt;&gt;&gt; x = &#123;1, 2, 3, 4, 5, 6&#125;&gt;&gt;&gt; y = &#123;7, 8, 9, 10, 11, 12&#125;&gt;&gt;&gt; print(x&amp;y)set()&gt;&gt;&gt; print(x.intersection(y))set()&gt;&gt;&gt; x.update([7,8,9])&gt;&gt;&gt; print(x.intersection(y))&#123;8, 9, 7&#125; 当二者无交集,则返回空set 2. - / difference – 差集:只在其一集合中出现 123456x = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;y = &#123;7, 8, 9, 10, 11, 12&#125;&gt;&gt;&gt; print(x-y)&#123;1, 2, 3, 4, 5, 6&#125;&gt;&gt;&gt; print(x.difference(y))&#123;1, 2, 3, 4, 5, 6&#125; 3. ^ / symmetric_difference – 对称差集:不同时出现在两个集合的元素 12&gt;&gt;&gt; print(x^y, x.symmetric_difference(y))&#123;1, 2, 3, 4, 5, 6, 10, 11, 12&#125; &#123;1, 2, 3, 4, 5, 6, 10, 11, 12&#125; 4. union() – 求并集 3 不可变集合 由于集合的元素可变,所以无法作为字典的键值 采用frozenset()可以创建不可变元素的不可变集合 123&gt;&gt;&gt; a = frozenset(&#123;1,2,3&#125;)&gt;&gt;&gt; print(a)frozenset(&#123;1, 2, 3&#125;)","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--类","slug":"Python/basic/类","date":"2021-07-07T07:33:24.000Z","updated":"2021-07-11T16:54:51.891Z","comments":true,"path":"2021/07/07/Python/basic/类/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E7%B1%BB/","excerpt":"类–CLASSpython中的类与对象类可以说是具有同类型属性（性质 方法 属性）的对象的属性集合 类中包含的就是该类对象共有的属性（性质 方法 属性）","text":"类–CLASSpython中的类与对象类可以说是具有同类型属性（性质 方法 属性）的对象的属性集合 类中包含的就是该类对象共有的属性（性质 方法 属性） 对象则是包含了类中具体属性（性质 方法 属性）的实体 对象则是具体指明 实现了类中各类属性的实体 新建一个类class关键字新建一个类: 123456789&gt;&gt;&gt; class stu:... name = &#x27;aa&#x27;... def display():... print(&#x27;im aa&#x27;)...&gt;&gt;&gt; print(stu.name)aa&gt;&gt;&gt; print(stu.display)&lt;function stu.display at 0x00000279CBA24798&gt; 新建一个类的实例对象12345&gt;&gt;&gt; cj = stu()&gt;&gt;&gt; print(cj.name)aa&gt;&gt;&gt; cj.display&lt;bound method stu.display of &lt;__main__.stu object at 0x00000279CBA36CC8&gt;&gt; 类属性除了自定义的属性 方法,python提供一系列的内置属性 __dict__: 包含命名空间的字典 __doc__: 类的说明文档 __name__：类的名称 __module__: 定义类的所在模块 __bases__: 包含基础类的元组12345678910111213&gt;&gt;&gt; class stu:... &#x27;this is test line&#x27;... name = &#x27;cj&#x27;... def dis():... print(&#x27;display&#x27;)...&gt;&gt;&gt; s = stu()&gt;&gt;&gt; print(s.__doc__)this is test line&gt;&gt;&gt; print(s.__dict__)&#123;&#125;&gt;&gt;&gt; print(s.__module__)__main__ 类构造方法__init__()方法用于对象被初始创建时调用,用于初始化生成类的具体属性 不同于java,python类的属性直接在init函数内声明,不需要额外声明12345678910&gt;&gt;&gt; class stu:... def __init__(self, init_name, init_age):... self.name = init_name... self.age = init_age... def introducing(self):... print(&quot;my name is &quot; + self.name + &#x27; and im &#x27; + str(self.age) + &#x27; old.&#x27;)...&gt;&gt;&gt; s = stu(&#x27;marklily&#x27;, 18)&gt;&gt;&gt; s.introducing()my name is marklily and im 18 old. 删除类的属性del用于删除对象的某个属性:12345&gt;&gt;&gt; s.__dict__&#123;&#x27;name&#x27;: &#x27;marklily&#x27;, &#x27;age&#x27;: 18&#125;&gt;&gt;&gt; del s.age&gt;&gt;&gt; s.__dict__&#123;&#x27;name&#x27;: &#x27;marklily&#x27;&#125; 继承继承中有子类与父类,甚至祖父类.子类继承父类中的所有属性 方法,并且可以添加新函数 属性 继承中的添加 子类继承父类中的所有方法,包括构造方法 12345678910111213141516171819# 创建父类class ParentClass: familyName = &#x27;c&#x27; familyLocation = &#x27;sc&#x27; def __init__(self, name, age): self.name = name self.age = age def introducing(self): print(&#x27;Name: &#x27; + self.name + &#x27;Age: &#x27; + str(self.age))# 创建一个父类对象 并检验相关属性parent = ParentClass(&#x27;markc&#x27;, 22)print(parent.familyName + parent.familyLocation)parent.introducing()# 创建子类 继承父类class ChildClass(ParentClass): passchild = ChildClass(&#x27;axlc&#x27;, 2)print(child.familyName + child.familyLocation)child.introducing() 1234cscName: markcAge: 22cscName: axlcAge: 2 子类添加新函数 新属性 1234567class ChildClass(ParentClass): newFamilyJob = &#x27;IT&#x27; def newJob(self): print(&#x27;new job is &#x27; + &#x27;IT&#x27;)child = ChildClass(&#x27;axlc&#x27;, 2)print(child.newFamilyJob)child.newJob() 12ITnew job is IT 继承中的覆写子类在继承父类方法时间,可对方法做出重写 1234567891011121314151617181920212223class ParentClass: familyName = &#x27;c&#x27; familyLocation = &#x27;sc&#x27; def __init__(self, name, age): self.name = name self.age = age def introducing(self): print(&#x27;Name: &#x27; + self.name + &#x27;Age: &#x27; + str(self.age))class ChildClass(ParentClass): newFamilyJob = &#x27;IT&#x27; def __init__(self, name, age, coupledNum): self.name = name self.age = age self.coupledNum = coupledNum def newJob(self): print(&#x27;new job is &#x27; + &#x27;IT&#x27;) def introducing(self): print(&#x27;Name: &#x27; + self.name + &#x27;Age: &#x27; + str(self.age) + &#x27;and i only got &#x27; + str(self.coupledNum))child = ChildClass(&#x27;axlc&#x27;, 2, 1)print(child.newFamilyJob)child.newJob()child.introducing() 12345cscName: markcAge: 22ITnew job is ITName: axlcAge: 2and i only got 1 子类中对构造函数做出了重写,新加入了coupledNum属性,对introducing方法也做出了重写 多重继承当一个子类有多个父类时,多个父类均被继承 12345678910111213141516171819202122232425&gt;&gt;&gt; class A:... def disA(self):... print(&#x27;A&#x27;)...&gt;&gt;&gt; class B:... def disB(self):... print(&#x27;B&#x27;)...&gt;&gt;&gt; class C:... def disC(self):... print(&#x27;C&#x27;)...&gt;&gt;&gt; class son(A,B,C):... def disSon(self):... print(&#x27;son&#x27;)...&gt;&gt;&gt; son = son()&gt;&gt;&gt; son.disA()A&gt;&gt;&gt; son.disB()B&gt;&gt;&gt; son.disC()C&gt;&gt;&gt; son.disSon()son 多级继承基因代代相传,孝景帝之子中山靖王之后刘玄德也可以用的 123456789101112131415161718&gt;&gt;&gt; class A:... def disA(self):... print(&#x27;A&#x27;)&gt;&gt;&gt; class D(A):... def disD(self):... print(&#x27;D&#x27;)...&gt;&gt;&gt; class E(D):... def disE(self):... print(&#x27;E&#x27;)...&gt;&gt;&gt; e = E()&gt;&gt;&gt; e.disA()A&gt;&gt;&gt; e.disD()D&gt;&gt;&gt; e.disE()E","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Numpy100--Numpy100","slug":"numpy/numpy100","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:38:41.199Z","comments":true,"path":"2021/07/07/numpy/numpy100/","link":"","permalink":"http://example.com/2021/07/07/numpy/numpy100/","excerpt":"github上的开源项目2021.7.4 17：06","text":"github上的开源项目2021.7.4 17：06 创建一个长度为10的空向量12z = np.zeros(10)print(z) 找到数组的内存大小12z = np.zeros(10)print(z.size * z.itermsize) z.size获取到内部的元素个数z.itemsize获取到各个元素的大小 从命令行对得到相关函数的说明文档1print(np.info(np.add)) 创建一个长度为10,且除了第五个元素为1的空向量123z = np.zeros(10)z[4] = 1print(z) 创建值域10-49的向量1z = np.arange(10, 50) 反转一个向量1234z = np.arange(0, 5)print(z)z = z[::-1]print(z) b = [0 1 2 3 4]a = b[x : y]: 两索引各自计算,正值从左侧开始,负值从右侧开始 左侧索引元素在右侧索引元素左侧,则返回非空 某侧无索引则代表,从另一侧索引顺方向计数完 a为两侧索引之内交集元素返回的array 若两侧索引之内无元素,则a为空array a = b[4:2] : a = []a = b[-3:4] : a = []a = b[4:-2] : a = [] x&gt;0 y&gt;0 a = b[x:y]: a = x-y内元素返回array a = b[ :y]: a = 0-y内元素返回 a = b[x: ]: a = x-len(b)内元素返回 x &lt; y : a = [] x&lt;0 or y&lt;0 a = b[-4:-1]: a = b中-4号元素到-1号元素返回 a = b[-4:1]: a = [] a = b[-4:]: a = -4 - 0索引之间元素返回 a = b[:-4]: a = [] a = b[3:-4]: a = [] a = b[::a] 在b中没隔a取一个元素返回a 取值方向由a正负决定 创建一个3 * 3,值域:0-8的矩阵12z = np.arange(0,9).reshape(3,3)print(z) 找到数组中的0元素索引12z = np.array([0, 1, 0, 3, 4, 0])print(z.nonzero()) 创建一个3 * 3的单位矩阵12z = np.eye(3)print(z) 创建一个3 * 3的随机数据123from numpy import randomz = np.random.random((3, 3, 3))print(z) 创建一个10 * 10的随机数组,并获取最小与最大值123from numpy import randomz = np.random.random((10, 10))print(z.min(), z.max()) 创建一个长度为30的随机向量,并获取其平均值1234from numpy import randomz = np.random.random((30))zMean = z.mean()print(zMean) 创建一个二维数组,其边界值为1,其余值为0123z = np.ones((6, 6))z[1:-1, 1:-1] = 0print(z) 其原理是:用array[a:b,c:d] = x进行对二维数组赋值的方式 array[1:-1,1:-1] = x其原理类似a = b[1:-1]从行索引为从第一行到-1行(及倒是第二行),这样根据每个array的大小去调整参数 对于一个存在的数组,如何用0填充其边界123z = np.ones((6, 6))z = np.pad(z, pad_width=1, mode=&#x27;constant&#x27;, constant_values=0)print(z) 下列各式的运行结果 0 * np.nan –&gt; nan np.nan==np.nan –&gt; False np.inf &gt; np.nan –&gt; False np.nan - np.nan –&gt; nan 0.3 == 3 * 0.1 –&gt; False nan 不是数字,是不存在 inf infinite 创建一个5 * 5的矩阵,并设置1 2 3 4落在其对角线的下方12Z = np.diag(1+np.arange(4), k = -1)print(Z) np.diag(array_like, k) 返回此array第k位置对角线的矩阵 当只传入矩阵,则返回此矩阵的对角线元素","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"Numpy","slug":"Python/Numpy","permalink":"http://example.com/categories/Python/Numpy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://example.com/tags/Numpy/"}]},{"title":"Numpy--NumpyNotes","slug":"numpy/NumpyNotes","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-11T16:56:29.098Z","comments":true,"path":"2021/07/07/numpy/NumpyNotes/","link":"","permalink":"http://example.com/2021/07/07/numpy/NumpyNotes/","excerpt":"Numpy1.ndarrayNumpy的数组类是ndarray，但其不同于array（只是一个以为数组）","text":"Numpy1.ndarrayNumpy的数组类是ndarray，但其不同于array（只是一个以为数组） ndarray.ndim:数组的dimension,Python中的rank nmarray.shape:数组的维数 ndarray.size:数组中所有元素的数量 ndarray.dtype:数组中所有元素的类型 ndarray.itemsize:数组中元素的大小,字节为单位 ndarray.data:存储array的缓冲12345678910111213def get_all_info(ndarr1): print(ndarr1, &#x27;basic info:&#x27;) print(&#x27;dimension:&#x27;, ndarr1.ndim) print(&#x27;shape:&#x27;, ndarr1.shape) print(&#x27;size:&#x27;, ndarr1.size) print(&#x27;dtype:&#x27;, ndarr1.dtype) print(&#x27;itemsize&#x27;, ndarr1.itemsize) print(&#x27;data:&#x27;, ndarr1.data)arr1 = np.array([1, 2])arr2 = np.array([(1,2,3), (4,5,6)])arr2 = np.array([(1,2,3), (4,5,6), (7,8,9)])get_all_info(arr1)get_all_info(arr2) this tures out:12345678910111213141516[1 2] basic info:dimension: 1shape: (2,)size: 2dtype: int32itemsize 4data: &lt;memory at 0x000001EEBB018348&gt;[[1 2 3] [4 5 6] [7 8 9]] basic info:dimension: 2shape: (3, 3)size: 9dtype: int32itemsize 4data: &lt;memory at 0x000001EEBB02F908&gt; TIPS: array.shape与np.shape()的区别 array.shape获取的是某个具体已声明的ndarray的属性,在其初始化时已经确定 np.shape()是np包中的一个方法,传入一个ndarray作为参数,获取其shape 123arr3 = np.array([(1,2,3), (4,5,6), (7,8,9)])print(&#x27;arr3.shape gets: &#x27;, arr3.shape)print(&#x27;np.shape(arr3) gets :&#x27;, np.shape(arr3)) this turns out: 12arr3.shape gets: (3, 3)np.shape(arr3) gets : (3, 3) 也可以在创建ndarray时指定数据类型(dtype): 1234arr3 = np.array([(1,2,3), (4,5,6), (7,8,9)])arr4 = np.array([(1,2,3), (4,5,6), (7,8,9)], dtype=np.uint8)print(&#x27;arr3`s dtype is&#x27;, arr3.dtype)print(&#x27;arr4`s dtype is&#x27;, arr4.dtype) it turns out: 12arr3s dtype is int32arr4s dtype is uint8 2.常见特定数组 zeros:数组中元素为0 ones:1 empty:类似与0,but not arange:在将一维数组按跨度分隔 linespace:将一维数组均分 random:随机 随机数方法:1234* random() 0-1内的随机实数* uniform(a, b) a-b内的随机浮点数* randint(a, b) a-b内的随机整数* 一些其他方法 1234567a = np.zeros((2, 3))b = np.ones((2, 3))c = np.empty((2, 4))d = np.arange(1, 2, 0.3)e = np.linspace(1, 2 ,7)f = np.random.random((2, 3))print(a,b,c,d,e,f) it turns out:1234567891011[[0. 0. 0.] [0. 0. 0.]][[1. 1. 1.] [1. 1. 1.]][[0.00000000e+000 0.00000000e+000 0.00000000e+000 0.00000000e+000] [0.00000000e+000 2.03555046e-321 1.42410974e-306 0.00000000e+000]][1. 1.3 1.6 1.9][1. 1.16666667 1.33333333 1.5 1.66666667 1.83333333 1. ][[0.56551478 0.58715817 0.51182441] [0.18129758 0.33167464 0.66718211]] TIPS: np.empty 创建一个没有任何具体值的ndarray数组，是创建数组最快的方法 不会给元素初始化值,运行速度快于ones,但具体使用需要用户手动赋值 形状与操作形状 reshape：用于基于现有数组和指定形状生成新数组，就是重塑行列1234a = np.arange(1, 10)print(&#x27;original a = \\n&#123;&#125;\\n&#x27;.format(a), &#x27;and shape = \\n&#123;&#125;\\n&#x27;.format(a.shape))a = a.reshape(3, -1)print(&#x27;a.reshape(3, -1) = \\n&#123;&#125;\\n&#x27;.format(a), &#x27;and shape = \\n&#123;&#125;\\n&#x27;.format(a.shape)) it turens out1234567891011original a = [1 2 3 4 5 6 7 8 9] and shape = (9,)a.reshape(3, -1) =[[1 2 3] [4 5 6] [7 8 9]] and shape =(3, 3) 其中参数2 = -1,即视情况而定,将其转换为3*3 reshape前后的元素个数一定保持一致才能进行转换 vstack：用于在垂直方向上堆叠多个数组(数组的维度必须匹配)123456a = np.arange(1, 3)print(&#x27;original a = \\n&#123;&#125;\\n&#x27;.format(a), &#x27;and shape = \\n&#123;&#125;\\n&#x27;.format(a.shape))b = np.arange(4, 6)print(&#x27;original b = \\n&#123;&#125;\\n&#x27;.format(b), &#x27;and shape = \\n&#123;&#125;\\n&#x27;.format(b.shape))c = np.vstack((a, b))print(&#x27;vstack ((a, b)) = c = \\n&#123;&#125;\\n&#x27;.format(c), &#x27;and shape = \\n&#123;&#125;\\n&#x27;.format(c.shape)) it turns out:12345678910111213original a = [1 2] and shape = (2,)original b =[4 5] and shape =(2,)vstack ((a, b)) = c =[[1 2] [4 5]] and shape =(2, 2) hstack：用于水平方向堆叠多个数组(数组的维度必须匹配) hsplit：用于水平分割数组 vsplit：用于垂直分割数组 index通过index访问数组中的数据 12a = np.array([(1,2,3),(4,5,6),(7,8,9)])print(a[1][2]) 16 可以通过创建一个包含目标index的数组来访问获取目标数组123a = np.arange(100, 200)a_index_five = np.arange(0, 100, 4)print(&#x27;a[a_index_five] = \\n&#123;&#125;\\n&#x27;.format(a[a_index_five])) it tures out:123a[a_index_five] = [100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196] 下标数组也可以是多维的,并将获得的数据转换为多维度数组(维度同下标数组)12345a = np.arange(100, 200)a_index_five = np.array([(1, 2), (10, 20)])print(&#x27;a_index_five = \\n&#123;&#125;\\n&#x27;.format(a_index_five), &#x27;shape= \\n&#123;&#125;\\n&#x27;.format(a_index_five.shape))a_select = a[a_index_five]print(&#x27;a[a_index_five] = \\n&#123;&#125;\\n&#x27;.format(a_select), &#x27;shape = \\n&#123;&#125;\\n&#x27;.format(a_select.shape)) it turns out:1234567891011a_index_five = [[ 1 2] [10 20]] shape= (2, 2) a[a_index_five] =[[101 102] [110 120]] shape =(2, 2) 二维数组的访问 一维访问123456a = np.arange(100, 200)a = a.reshape(10, -1)# 指定一个下标[i],则获取该行元素(第i个数组)print(a[0])# 指定两个连续的下标[i][j],则获取该行该个元素(i行j列)print(a[0][3]) it turns out12[100 101 102 103 104 105 106 107 108 109]103 二维访问需通过:指定范围1print(&#x27;a[2:4, 2:5 = \\n&#123;&#125;\\n&#x27;.format(a[2:4, 2:5])) turns out:12[[122 123 124][132 133 134]] 2:4, 2:5指第2 3行下的第 2 3 4列Tips:使用x,: 或 :,y 获取第x行所有 与 y列所有 1print(&#x27;a[2,:] = \\n&#123;&#125;\\n&#x27;.format(a[2,:])) turns out12a[2,:] = [120 121 122 123 124 125 126 127 128 129] 矩阵np中矩阵仍然是ndarray,只是以矩阵的方式操作 转置1234a = np.random.randint(0, 4, size=[4, 4]) print(&#x27;original a = \\n&#123;&#125;\\n&#x27;.format(a))print(&#x27;a.T = \\n&#123;&#125;\\n&#x27;.format(a.T))print(&#x27;a.transpose = \\n&#123;&#125;\\n&#x27;.format(a.transpose())) turns out: 123456789101112131415[0 2 1 2][3 0 1 3][2 0 0 3]]a.T =[[0 0 3 2][1 2 0 0][3 1 1 0][1 2 3 3]]a.transpose =[[0 0 3 2][1 2 0 0][3 1 1 0][1 2 3 3]] dot乘法 123456a = np.random.randint(0, 4, size=[4, 4]) b = np.uint(np.ones((4, 1)))c = np.dot(a, b)print(&#x27;a shape = \\n&#123;&#125;\\n&#x27;.format(a.shape),&#x27;\\n&#x27;, &#x27;b shape = \\n&#123;&#125;\\n&#x27;.format(b.shape))print(a.dot(b))print(&#x27;c shape = \\n&#123;&#125;\\n&#x27;.format(c.shape)) turns out: 123456789101112a shape = (4, 4)b shape =(4, 1)[[8][5][6][6]]c shape =(4, 1)","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"Numpy","slug":"Python/Numpy","permalink":"http://example.com/categories/Python/Numpy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://example.com/tags/Numpy/"}]},{"title":"MarkLily Blog Test","slug":"test/numpy100","date":"2021-07-07T07:22:24.000Z","updated":"2021-12-16T08:48:30.147Z","comments":true,"path":"2021/07/07/test/numpy100/","link":"","permalink":"http://example.com/2021/07/07/test/numpy100/","excerpt":"github上的开源项目2021.7.4 17：06","text":"github上的开源项目2021.7.4 17：06 创建一个长度为10的空向量12z = np.zeros(10)print(z) 找到数组的内存大小12z = np.zeros(10)print(z.size * z.itermsize) z.size获取到内部的元素个数z.itemsize获取到各个元素的大小 从命令行对得到相关函数的说明文档1print(np.info(np.add)) 创建一个长度为10,且除了第五个元素为1的空向量123z = np.zeros(10)z[4] = 1print(z) 创建值域10-49的向量1z = np.arange(10, 50) 反转一个向量1234z = np.arange(0, 5)print(z)z = z[::-1]print(z) b = [0 1 2 3 4]a = b[x : y]: 两索引各自计算,正值从左侧开始,负值从右侧开始 左侧索引元素在右侧索引元素左侧,则返回非空 某侧无索引则代表,从另一侧索引顺方向计数完 a为两侧索引之内交集元素返回的array 若两侧索引之内无元素,则a为空array a = b[4:2] : a = []a = b[-3:4] : a = []a = b[4:-2] : a = [] x&gt;0 y&gt;0 a = b[x:y]: a = x-y内元素返回array a = b[ :y]: a = 0-y内元素返回 a = b[x: ]: a = x-len(b)内元素返回 x &lt; y : a = [] x&lt;0 or y&lt;0 a = b[-4:-1]: a = b中-4号元素到-1号元素返回 a = b[-4:1]: a = [] a = b[-4:]: a = -4 - 0索引之间元素返回 a = b[:-4]: a = [] a = b[3:-4]: a = [] a = b[::a] 在b中没隔a取一个元素返回a 取值方向由a正负决定 创建一个3 * 3,值域:0-8的矩阵12z = np.arange(0,9).reshape(3,3)print(z) 找到数组中的0元素索引12z = np.array([0, 1, 0, 3, 4, 0])print(z.nonzero()) 创建一个3 * 3的单位矩阵12z = np.eye(3)print(z) 创建一个3 * 3的随机数据123from numpy import randomz = np.random.random((3, 3, 3))print(z) 创建一个10 * 10的随机数组,并获取最小与最大值123from numpy import randomz = np.random.random((10, 10))print(z.min(), z.max()) 创建一个长度为30的随机向量,并获取其平均值1234from numpy import randomz = np.random.random((30))zMean = z.mean()print(zMean) 创建一个二维数组,其边界值为1,其余值为0123z = np.ones((6, 6))z[1:-1, 1:-1] = 0print(z) 其原理是:用array[a:b,c:d] = x进行对二维数组赋值的方式 array[1:-1,1:-1] = x其原理类似a = b[1:-1]从行索引为从第一行到-1行(及倒是第二行),这样根据每个array的大小去调整参数 对于一个存在的数组,如何用0填充其边界123z = np.ones((6, 6))z = np.pad(z, pad_width=1, mode=&#x27;constant&#x27;, constant_values=0)print(z) 下列各式的运行结果 0 * np.nan –&gt; nan np.nan==np.nan –&gt; False np.inf &gt; np.nan –&gt; False np.nan - np.nan –&gt; nan 0.3 == 3 * 0.1 –&gt; False nan 不是数字,是不存在 inf infinite 创建一个5 * 5的矩阵,并设置1 2 3 4落在其对角线的下方12Z = np.diag(1+np.arange(4), k = -1)print(Z) np.diag(array_like, k) 返回此array第k位置对角线的矩阵 当只传入矩阵,则返回此矩阵的对角线元素","categories":[{"name":"Test","slug":"Test","permalink":"http://example.com/categories/Test/"}],"tags":[{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]},{"title":"python--列表操作","slug":"Python/tool/列表操作","date":"2021-07-07T07:22:24.000Z","updated":"2023-04-17T15:19:42.734Z","comments":true,"path":"2021/07/07/Python/tool/列表操作/","link":"","permalink":"http://example.com/2021/07/07/Python/tool/%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"多线程判断列表中是否存在另一个元素/列表12345678910111213141516171819202122232425262728293031def contain(ori:list|tuple, tar) -&gt; bool: &#x27;&#x27;&#x27;判断一个给定的可迭代对象中是否存在另一个对象 Args: ori (list | tuple): 原始可迭代对象 tar (_type_): 目标对象 Returns: bool: 是否存在 &#x27;&#x27;&#x27; # 如果传入的是可迭代对象并且不是字符串 if hasattr(tar, &#x27;__iter__&#x27;) and isinstance(tar, str) is not True: # 如果传入对象中还有元素 if len(tar) &gt; 0: # 则取出最后一个对象传入本函数进行判断 if contain(ori=ori, tar=tar[-1]): # 如果上一步返回true 则将传入对象去掉最后一个元素后继续传入本函数 tar.pop() tmp = contain(ori=ori, tar=tar) return tmp else: return False # 如果上一步返回false 则直接本函数返回false else: # 如果已经完成迭代 则返回true return True # 如果传入的是单一对象 else: for i in ori: if tar == i:return True else: pass return False 从列表中去除另一个元素/列表1234567891011121314151617def remove_items(ori:list, tar) -&gt; list: &#x27;&#x27;&#x27;从一个列表中删除另一个列表或元素 Args: ori (list): 原始列表 tar (_type_): 待删除的列表或者元素 Returns: list: 删除给定元素/列表的原列表 &#x27;&#x27;&#x27; # 如果传入的待去除对象为none 则直接返回原列表 if tar is None: return ori # 如果传入的不是none 则先判断其是否为非str的可迭代对象 if hasattr(tar, &quot;__iter__&quot;) and isinstance(tar, str) is not True: return [x for x in ori if x not in tar] else: return [x for x in ori if x != tar]","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"tool","slug":"Python/tool","permalink":"http://example.com/categories/Python/tool/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--map函数","slug":"Python/advance/map函数","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-11T16:55:03.976Z","comments":true,"path":"2021/07/07/Python/advance/map函数/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/map%E5%87%BD%E6%95%B0/","excerpt":"map函数 python内置函数 会根据给定函数,对指定序列做出映射","text":"map函数 python内置函数 会根据给定函数,对指定序列做出映射 mapmap(function, iterable...) iterable 作为映射中原数据的来源 function 用于对iterable中的元素进行转换 1234&gt;&gt; def squ(x):... return x * x...&gt;&gt;&gt; mapResult = map(squ, [1,2,3,4,5]) python 2. 返回列表 python 3. 返回迭代器 12345678910&gt;&gt;&gt; print(mapResult.__class__)&lt;class &#x27;map&#x27;&gt;&gt;&gt;&gt; for i in mapResult:... print(i)...1491625 可通过list(map())的显示转换来消除版本之间的差异 123456&gt;&gt;&gt; def squ(x):... return x * x...&gt;&gt;&gt; list1 = list(map(squ, [1,2,3,4,5]))&gt;&gt;&gt; print(list1)[1, 4, 9, 16, 25] lambda12&gt;&gt;&gt; print(list(map(lambda x : x * x, [1,2,3,4,5])))[1, 4, 9, 16, 25] 技巧map完成数据类型转换12&gt;&gt;&gt; print(list(map(str, [1,2,3,4,5])))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;] map元组转列表123&gt;&gt;&gt; list1 = list(map(int,(1,2,3)))&gt;&gt;&gt; print(list1)[1, 2, 3] 原理是:元组作为迭代器可作为map()函数参数传入,当元组内部元素数据类型与function转出数据类型一致时,再将map返回迭代器转为列表","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--列表推导式","slug":"Python/advance/列表推导式","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:36:00.594Z","comments":true,"path":"2021/07/07/Python/advance/列表推导式/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/","excerpt":"列表推导式列表推导式基础 result = [ &lt;expression&gt; for &lt;element&gt; in &lt;iterable&gt; ] 根据现有迭代器类iterable","text":"列表推导式列表推导式基础 result = [ &lt;expression&gt; for &lt;element&gt; in &lt;iterable&gt; ] 根据现有迭代器类iterable 对其中每个元素element 根据函数expression进行相应变化得到结果元素 将结果元素立即添加到result中123&gt;&gt;&gt; testSquares = [x * x for x in (1,2,3,4,5)]&gt;&gt;&gt; print(testSquares)[1, 4, 9, 16, 25] if条件(可选):result = [ &lt;expression&gt; for &lt;element&gt; in &lt;iterable&gt; if &lt;condition&gt; ] 每个元素在进行expression前。 所有结果将在新列表中立即返回。 Python 中的生成器表达式是懒惰地计算的，但是列表推导会立即施加到整个迭代器，它消耗与迭代器长度成比例的内存。123&gt;&gt;&gt; testSquares = [x * x for x in (1,2,3,4,5) if x % 2 == 0]&gt;&gt;&gt; print(testSquares)[4, 16] 12* 根据列表``(1,2,3,4,5)`` 创建一个平方数列表,* 只选择其中的偶数进行创建 else:if...else 判断是在 for 循环之前使用，而非以后： if...else在for后 报错12345&gt;&gt;&gt; testStr = [x for x in &#x27;abcd&#x27; if x is &#x27;a&#x27; else &#x27;b&#x27;] File &quot;&lt;stdin&gt;&quot;, line 1 testStr = [x for x in &#x27;abcd&#x27; if x is &#x27;a&#x27; else &#x27;b&#x27;] ^SyntaxError: invalid syntax if...else 在 for 前 123&gt;&gt;&gt; testStr = [x if x is &#x27;a&#x27; else &#x27;b&#x27; for x in &#x27;abcd&#x27;]&gt;&gt;&gt; print(testStr)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;]","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--装饰器","slug":"Python/advance/python装饰器","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:36:20.340Z","comments":true,"path":"2021/07/07/Python/advance/python装饰器/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/python%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"装饰器Python装饰器能够动态地改变函数 方法 类的功能,而不用子类重写或修改函数源代码的方式","text":"装饰器Python装饰器能够动态地改变函数 方法 类的功能,而不用子类重写或修改函数源代码的方式 装饰器函数装饰器函数基础装饰器 增强了其他函数的功能 任何将函数作为传入参数并返回一个增强函数的函数都可以视为一个装饰器函数12345678910# 定义装饰器函数def decoratorFunc(f): return f# 语法糖 进行函数装饰@decoratorFunc# 定义待装饰函数def toBeEnforce(): print(&#x27;this function has been enforced&#x27;)# 调用增强后的函数toBeEnforce() 装饰器函数语法糖 @decoratorFunction作为语法糖:1@decoratorFunc 等效于:1my_function = super_secret_function(my_function) 以上代码等效于12345678910# 定义装饰器函数def decoratorFunc(f): return f# 定义待装饰函数def toBeEnforce(): print(&#x27;this function has been enforced&#x27;)# 进行装饰toBeEnforce = decoratorFunc(toBeEnforce)# 调用装饰后的函数toBeEnforce() 当然,此案例没有函数装饰作用装饰器函数理解 假设我们现有一个函数用于计算函数的sin cos值的函数:12345&gt;&gt;&gt; def calSinCos(alpha):... return [math.sin(alpha), math.cos(alpha)]...&gt;&gt;&gt; calSinCos(0.5)[0.479425538604203, 0.8775825618903728] 现需要这个函数输出这个角度半角的sin cos的值 solution1: ``calSinCos(aplha/2) 12&gt;&gt;&gt; calSinCos(0.5/2)[0.24740395925452294, 0.9689124217106447] solution2: 使用装饰器,使这个函数同时返回我们需要的两个值: 12345678910111213141516&gt;&gt;&gt; def decoratorCal(f):... def inner_function(*args, **kwargs):... temp_list_sin = []... temp_list_cos = []... for i in args:... temp_list_sin.append(math.sin(i))... temp_list_cos.append(math.cos(i))... return f(*args, **kwargs), temp_list_sin, temp_list_cos... return inner_function...&gt;&gt;&gt; @decoratorCal... def cal(a):... return [math.sin(a), math.cos(a)]...&gt;&gt;&gt; print(cal(0.3))([0.29552020666133955, 0.955336489125606], [0.29552020666133955], [0.955336489125606]) 装饰器函数工作流程: 调用待增强函数cal(0.3)时,同时调用装饰器函数decoratorCal decoratorCal内部定义了我们真正寄希望完成预期功能的函数inner_function return inner_function时便开始执行inner_function内代码,首先是完成基于原cal(0.3)的新加功能,最后return f(*args, **kwargs) 当然也可以return 其他想要的数据 不一定要返回原函数 return f(*args, **kwargs)便开始执行cal(0.3)原函数的功能 最后得到所有的返回值 从流程上看,cal原函数作为参数,真正运行的是inner_function,inner_function运行后返回cal,cal再运行本身的功能 之所以decoratorCal必须返回一个函数inner_function,是为了借return来执行inner_function内部我们新加功能的代码 装饰器更像是一种语法逻辑的产物 装饰器类将装饰器封装为类, 12345678910111213141516# 定义装饰器类class Decorator(object): # 初始化,将待装饰方法赋值给装饰器类,作为其属性(对象方法) def __init__(self, func): self.func = func def __call__(self, *args, **kwargs): # 调用此方法 res = self.func(*args, **kwargs) def testfunc(): print(&#x27;Inside the function.&#x27;)testfunc = Decorator(testfunc)testfunc()","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--发生器","slug":"Python/advance/发生器","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:35:54.441Z","comments":true,"path":"2021/07/07/Python/advance/发生器/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/%E5%8F%91%E7%94%9F%E5%99%A8/","excerpt":"发生器 Python发生器通过关键字yeild创建 或通过发生器表达式 expression for x in an_iterator创建","text":"发生器 Python发生器通过关键字yeild创建 或通过发生器表达式 expression for x in an_iterator创建 生成器保存的算法而非具体数据,因此节约了内存 发生器 发生器返回对象为 generator 发生器表达式 发生器类似于列表推导式,但发生器用()声明 当发生器作为函数的唯一参数时,不必多重括号: 1234567891011121314151617&gt;&gt;&gt; def printL(list1):... for i in list1:... print(i)...&gt;&gt;&gt; printL(x * 2 for x in range(10))024681012141618&gt;&gt;&gt; print((x * 2 for x in range(10)).__class__)&lt;class &#x27;generator&#x27;&gt; 发生器函数 生成器函数类似常规函数 生成器函数内部有多个或一个yield关键字 生成器函数无返回值 return 如果要提前停止发生器,则提前使用空return 12345678910111213&gt;&gt;&gt; def generatorFunc():... for i in range(5):... yield i * 2...&gt;&gt;&gt; l = generatorFunc()&gt;&gt;&gt; for i in l:... print(i)...02468 所有的生成器表达式都有自己对应的生成器函数,反之亦然一次性生成器对象是一次性的,当一次迭代完成后,则该生成器对象内部函数被销毁 12345678910111213&gt;&gt;&gt; l = generatorFunc()&gt;&gt;&gt; for i in l:... print(i)...02468&gt;&gt;&gt; print(next(l))Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 生成器的主体不会立即执行：当调用生成器函数时，它只会返回生成器对象，而不去执行第一个 print 语句。 这使得生成器比返回列表的函数消耗更少的内存，并且它能够实现生成无限长的序列。 因此,生成器通常用于数据科学以及涉及大量数据的其他环境。 另一个优点是其他代码可以立即使用生成器产生的值，而无需等待生成完整的序列。 但是，如果你需要多次使用生成器生成的值，并且如果生成它们的成本高于存储，则将 list 生成的值存储为比重新生成序列更好。 .next()函数用于从生成器中获取值,并提供迭代结束的默认值","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--多线程","slug":"Python/advance/多线程","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:35:48.758Z","comments":true,"path":"2021/07/07/Python/advance/多线程/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"多线程python多线程并非真正意义上的多线程 每个进程运行时都需要等到GIL释放,然后得到GIL后上锁 因此,同一时间只有一个python线程在运行","text":"多线程python多线程并非真正意义上的多线程 每个进程运行时都需要等到GIL释放,然后得到GIL后上锁 因此,同一时间只有一个python线程在运行 创建线程 threading.Thread使用threading,创建新的threading.Thread,为其分配要执行的函数来启动新的执行线程12345&gt;&gt;&gt; import threading&gt;&gt;&gt; def test():... print(&quot;Running...&quot;)...&gt;&gt;&gt; test_thread = threading.Thread(target=test) target 传入函数或可调用对象 在Thread调用start()方法前,线程不会开始 开始线程 Thread.start()Thread.start()开始线程 12&gt;&gt;&gt; test_thread.start()Running... 当一个线程运行结束,再次调用start()方法,则会报错: 12345678&gt;&gt;&gt; test_thread.start()Running...&gt;&gt;&gt; test_thread.start()Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;File &quot;D:\\Python37\\lib\\threading.py&quot;, line 848, in start raise RuntimeError(&quot;threads can only be started once&quot;)RuntimeError: threads can only be started once 若想将线程设置为守护线程持续运行,则需设置daemon=True 加入线程 Thread.join()","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--拷贝","slug":"Python/advance/数据拷贝","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:36:02.929Z","comments":true,"path":"2021/07/07/Python/advance/数据拷贝/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D/","excerpt":"拷贝 浅拷贝(shallow copy), 仅拷贝指向对象的指针 深拷贝(`deep copy``),将整个对象拷贝至另外一块内存","text":"拷贝 浅拷贝(shallow copy), 仅拷贝指向对象的指针 深拷贝(`deep copy``),将整个对象拷贝至另外一块内存 浅拷贝 假设原有一个列表la = [1,2,3,[4,5,6]],将其浅拷贝到lb lb中某个元素改变时,会直接根据指针指向此列表所在内存,改变此列表值 最终la值也改变 1234567&gt;&gt;&gt; la = [1,2,3,[4,5,6]]&gt;&gt;&gt; lb = la&gt;&gt;&gt; lb[0] = &#x27;a&#x27;&gt;&gt;&gt; print(lb)[&#x27;a&#x27;, 2, 3, [4, 5, 6]]&gt;&gt;&gt; print(la)[&#x27;a&#x27;, 2, 3, [4, 5, 6]] 12345&gt;&gt;&gt; a = [1,2,[3,4]]&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; b[2][1] = 0 &gt;&gt;&gt; print(a)[1, 2, [3, 0]] 深拷贝通过引入copy,使用copy.deepcopy()方法12345678&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1,2,[3,4]]&gt;&gt;&gt; c = copy.deepcopy(a)&gt;&gt;&gt; c[2][1] = 99&gt;&gt;&gt; print(c)[1, 2, [3, 99]]&gt;&gt;&gt; print(a)[1, 2, [3, 0]]","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--运算符重载","slug":"Python/advance/运算符重载","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:36:11.392Z","comments":true,"path":"2021/07/07/Python/advance/运算符重载/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"运算符重载 python中一切都是对象,每个对象都有一些特殊的内部方法 这些方法都遵循__action__的命名规定","text":"运算符重载 python中一切都是对象,每个对象都有一些特殊的内部方法 这些方法都遵循__action__的命名规定 通过运算符重载,可以让类进行一些数学运算123456789101112131415161718192021222324252627282930313233343536373839class Vector(object): def __init__(self, x, y): self.x = x self.y = y def __add__(self, v): # Addition with another vector. return Vector(self.x + v.x, self.y + v.y) def __sub__(self, v): # Subtraction with another vector. return Vector(self.x - v.x, self.y - v.y) def __mul__(self, s): # Multiplication with a scalar. return Vector(self.x * s, self.y * s) def __div__(self, s): # Division with a scalar. float_s = float(s) return Vector(self.x / float_s, self.y / float_s) def __floordiv__(self, s): # Division with a scalar (value floored). return Vector(self.x // s, self.y // s) def __repr__(self): # Print friendly representation of Vector class. Else, it would # show up like, &lt;__main__.Vector instance at 0x01DDDDC8&gt;. return &#x27;&lt;Vector (%f, %f)&gt;&#x27; % (self.x, self.y, )a = Vector(3, 5)b = Vector(2, 7)print a + b # Output: &lt;Vector (5.000000, 12.000000)&gt;print b - a # Output: &lt;Vector (-1.000000, 2.000000)&gt;print b * 1.3 # Output: &lt;Vector (2.600000, 9.100000)&gt;print a // 17 # Output: &lt;Vector (0.000000, 0.000000)&gt;print a / 17 # Output: &lt;Vector (0.176471, 0.294118)&gt;","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--数组","slug":"Python/basic/数组","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:36:51.080Z","comments":true,"path":"2021/07/07/Python/basic/数组/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E6%95%B0%E7%BB%84/","excerpt":"数组-array数组的基本性质: 数组本身不属于基本数据类型,需要导入array使用数组 数组内部元素类型相同","text":"数组-array数组的基本性质: 数组本身不属于基本数据类型,需要导入array使用数组 数组内部元素类型相同 数组不同于列表:内部元素相同,列表内部元素可以不同 人如其名,内部元素只能是数字数组定义 声明一个数组,必须遵循基本语法:arrayName = array(typecode, [initializers]): typecode:str 123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,2,3,4])&gt;&gt;&gt; print(arr1, arr1.__class__)array(&#x27;i&#x27;, [1, 2, 3, 4]) &lt;class &#x27;array.array&#x27;&gt; 当声明数据类型与initializers数据类型不一,则报错: 1234&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,2.2,3,4])Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: integer argument expected, got float 指定数据类型后,initializers可为空: 123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[])&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;) 访问数组索引–[]123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,3,4,5,6,7,5])&gt;&gt;&gt; print(arr1[1])3 切片–:12&gt;&gt;&gt; print(arr1[1:])array(&#x27;i&#x27;, [3, 4, 5, 6, 7, 5]) index(x)返回首次出现x的最小索引123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,3,4,5,6,7,5])&gt;&gt;&gt; print(arr1.index(5))3 负索引修改数组append()将一个元素添加到数组末尾1234&gt;&gt;&gt; a = array(&#x27;i&#x27;, [1,2,3,4,5,7,8,9])&gt;&gt;&gt; a.append(10)&gt;&gt;&gt; print(a)array(&#x27;i&#x27;, [1, 2, 3, 4, 5, 7, 8, 9, 10]) insert(x, i)将元素x指定添加到i处1234&gt;&gt;&gt; a = array(&#x27;i&#x27;, [1,2,3])&gt;&gt;&gt; a.insert(1, 22)&gt;&gt;&gt; print(a)array(&#x27;i&#x27;, [1, 22, 2, 3]) extend(x)将x元素添加到数组,若x时数组,则二者应有相同的数据类型12345&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;, [1,2,3])&gt;&gt;&gt; arr2 = array(&#x27;i&#x27;, [3,4,5])&gt;&gt;&gt; arr1.extend(arr2)&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [1, 2, 3, 3, 4, 5]) fromlist()将list中的元素添加到数组中12345&gt;&gt;&gt; a = array(&#x27;i&#x27;, [1,2,3,4,5,7,8,9])&gt;&gt;&gt; l = [10,11]&gt;&gt;&gt; a.fromlist(l)&gt;&gt;&gt; print(a)array(&#x27;i&#x27;, [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]) reverse()反转数组12345678910&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [1, 2, 3, 3, 4, 5])&gt;&gt;&gt; print(arr1.reverse())None&gt;&gt;&gt; arr1.reverse()&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [1, 2, 3, 3, 4, 5])&gt;&gt;&gt; arr1.reverse()&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [5, 4, 3, 3, 2, 1]) +将两个数组拼接12&gt;&gt;&gt; print(arr1 + arr2)array(&#x27;i&#x27;, [5, 4, 3, 3, 2, 1, 3, 4, 5]) *将数组复制添加到本身12&gt;&gt;&gt; print(arr1*2)array(&#x27;i&#x27;, [5, 4, 3, 3, 2, 1, 5, 4, 3, 3, 2, 1]) del arr[i]删除某个元素,或数组12345&gt;&gt;&gt; arr1array(&#x27;i&#x27;, [4, 3, 3, 2, 1])&gt;&gt;&gt; del arr1[0]&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [3, 3, 2, 1]) 12345&gt;&gt;&gt; del arr1&gt;&gt;&gt; print(arr1)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;arr1&#x27; is not defined remove()从数组中删除第一个出现的x元素12345&gt;&gt;&gt; arr2array(&#x27;i&#x27;, [3, 4, 5, 3, 4, 5])&gt;&gt;&gt; arr2.remove(3)&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 3, 4, 5]) pop()删除并返回数组的最后一个元素12345&gt;&gt;&gt; arr2array(&#x27;i&#x27;, [3, 4, 5, 3, 4, 5])&gt;&gt;&gt; arr2.remove(3)&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 3, 4, 5]) 也可指定pop对象索引123456&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 3, 4])&gt;&gt;&gt; arr2.pop(2)3&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 4])","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--文件夹","slug":"Python/tool/文件夹","date":"2021-07-07T07:22:24.000Z","updated":"2023-04-17T15:21:15.479Z","comments":true,"path":"2021/07/07/Python/tool/文件夹/","link":"","permalink":"http://example.com/2021/07/07/Python/tool/%E6%96%87%E4%BB%B6%E5%A4%B9/","excerpt":"","text":"多线程获取一级子文件夹123456789101112131415161718192021222324252627282930313233343536373839404142434445import osdef remove_items(ori:list, tar) -&gt; list: &#x27;&#x27;&#x27;从一个列表中删除另一个列表或元素 Args: ori (list): 原始列表 tar (_type_): 待删除的列表或者元素 Returns: list: 删除给定元素/列表的原列表 &#x27;&#x27;&#x27; # 如果传入的待去除对象为none 则直接返回原列表 if tar is None: return ori # 如果传入的不是none 则先判断其是否为非str的可迭代对象 if hasattr(tar, &quot;__iter__&quot;) and isinstance(tar, str) is not True: return [x for x in ori if x not in tar] else: return [x for x in ori if x != tar] def get_subfolders(path_:str, ignore = None): &#x27;&#x27;&#x27;读取给定文件夹路径内的一级子文件名 Args: path_ (str): 文件夹路径 Returns: list: 子文件夹名 &#x27;&#x27;&#x27; assert os.path.exists(path_), f&quot;&#123;path_&#125; Not Exist.&quot; # 定义一个列表，用来存储结果 list_ = [] # 获取该目录下的所有文件或文件夹目录 files = os.listdir(path_) for file in files: # 得到该文件下所有目录的路径 tmp_path = os.path.join(path_, file) # 如果该路径为文件夹 if os.path.isdir(tmp_path): list_.append(os.path.split(tmp_path)[1]) if ignore is None: return list_, (os.path.join(path_, x) for x in list_) else: remove_items(list_, ignore) return list_, (os.path.join(path_, x) for x in list_)","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"tool","slug":"Python/tool","permalink":"http://example.com/categories/Python/tool/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Pyhont--字典","slug":"Python/basic/字典","date":"2021-07-07T07:02:24.000Z","updated":"2021-07-10T14:36:59.106Z","comments":true,"path":"2021/07/07/Python/basic/字典/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E5%AD%97%E5%85%B8/","excerpt":"字典-Dictionary字典的基本性质: 字典是python的内置数据类型 字典的数据是键值对一一对应,根据键索引指定值","text":"字典-Dictionary字典的基本性质: 字典是python的内置数据类型 字典的数据是键值对一一对应,根据键索引指定值 创建字典1. 使用&#123;&#125;创建字典,声明其类型 字典键是不可变数据类型,用元组或不可变集合创建 字典值是可变数据类型12345&gt;&gt;&gt; dict1 = &#123;1:&#x27;value1&#x27;, &#x27;key2&#x27;:&#x27;value2&#x27;&#125;&gt;&gt;&gt; print(type(dict1))&lt;class &#x27;dict&#x27;&gt;&gt;&gt;&gt; print(dict1[1])value1 键只能是不可变数据类型:元组 不可变集合值都可 123&gt;&gt;&gt; dict1 = &#123;tp1:tp1&#125;&gt;&gt;&gt; print(dict1, dict1.__class__)&#123;(3, 2, 11): (3, 2, 11)&#125; &lt;class &#x27;dict&#x27;&gt; 2. 使用dict()初始化字典 12345&gt;&gt;&gt; d&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[2]&#x27;Pink&#x27; 访问字典键12345678&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[2]&#x27;Pink&#x27;&gt;&gt;&gt; d[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 3 []索引找不到值则报错 get()123456789101112131415&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[2]&#x27;Pink&#x27;&gt;&gt;&gt; d[1]&#x27;Blue&#x27;&gt;&gt;&gt; d.get(1)&#x27;Blue&#x27;&gt;&gt;&gt; d[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 3&gt;&gt;&gt; d.get(3)&gt;&gt;&gt; print(d.get(3))None 当.get()方法找不到值,则返回None 更新值使用键定位,更新值 12345&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[1] = &#x27;cjblue&#x27;&gt;&gt;&gt; print(d)&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;&#125; 直接使用新键,则添加新值 12345&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[5] = &#x27;marklily&#x27;&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;, 5: &#x27;marklily&#x27;&#125; 删除元素1. pop() 删除并返回给定键的值 123456&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;, 5: &#x27;marklily&#x27;&#125;&gt;&gt;&gt; d.pop(2)&#x27;Pink&#x27;&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;&#125; 2. popitem() 删除并返回任意一个键值对 123456&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;, 3: &#x27;floyd&#x27;&#125;&gt;&gt;&gt; d.popitem()(3, &#x27;floyd&#x27;)&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;&#125; 3. clear() 删除所有元素但不删除字典本身 123&gt;&gt;&gt; d.clear()&gt;&gt;&gt; d&#123;&#125; 4. del 删除特定键值对或删除整个字典 12345678910&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;, 3: &#x27;floyd&#x27;&#125;&gt;&gt;&gt; del d[1]&gt;&gt;&gt; d&#123;5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;, 3: &#x27;floyd&#x27;&#125;&gt;&gt;&gt; del d&gt;&gt;&gt; dTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;d&#x27; is not defined","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--递归","slug":"Python/basic/递归","date":"2021-07-07T05:40:24.000Z","updated":"2021-07-10T14:36:29.588Z","comments":true,"path":"2021/07/07/Python/basic/递归/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E9%80%92%E5%BD%92/","excerpt":"递归","text":"递归 举例计算阶乘 12345678910&gt;&gt;&gt; def cal(n):... if n == 1:... return 1... else:... return n * cal(n - 1)...&gt;&gt;&gt; print(cal(4))24&gt;&gt;&gt; print(cal(6))720 递归函数内部会调用函数本身 某次调用递归函数时,内部调用本身时会指定参数 在递归函数中,应有一个结束参数信号,在每次递归中,参数不断靠近该信号递归次数限制python递归次数限制为3000次,超出此次数则会触发RecursionError移除递归次数限制sys.setrecursionlimit(5000) 设置次数限制为我们所需要的次数","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Pandas--基础","slug":"Python/basic/Pandas基础","date":"2021-07-07T02:40:24.000Z","updated":"2021-07-11T16:55:20.155Z","comments":true,"path":"2021/07/07/Python/basic/Pandas基础/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/Pandas%E5%9F%BA%E7%A1%80/","excerpt":"2142Pandas数据结构pandas有两种数据结构：Series and dataframe数据框","text":"2142Pandas数据结构pandas有两种数据结构：Series and dataframe数据框 SeriesSeries是一个一维标记数组，可以存储任何种类的数据 12my_series = pd.Series([3,-5,7,4], index=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])print(my_series) 12345a 3b -5c 7d 4dtype: int64 Series中的数据可通过index找到 1print(my_series[&#x27;d&#x27;]) 14 series类似于字典(当然这只是个人直观感受) dataframe是一个二维数据结构,包含不同的列 12345678data = &#123; &#x27;Country&#x27; : [&#x27;Belgium&#x27;, &#x27;India&#x27;, &#x27;Brazil&#x27; ], &#x27;Capital&#x27;: [&#x27;Brussels&#x27;, &#x27;New Delhi&#x27;, &#x27;Brassilia&#x27;], &#x27;Population&#x27;: [1234,1234,1234]&#125;datas = pd.DataFrame(data, columns=[&#x27;Country&#x27;,&#x27;Capital&#x27;,&#x27;Population&#x27;])print(type(data))print(type(datas))print(datas) 123456&lt;class &#x27;dict&#x27;&gt;&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;Country Capital Population0 Belgium Brussels 12341 India New Delhi 12342 Brazil Brassilia 1234 创建dataframe时,在写入或打印时会自动生成从第一行正式数据开始的行序号 and 第一列正式数据开始的列序号dataframe类似于数组,可直接使用行列序号进行访问具体的数据 调用/读取数据 CSV文件 12pd = pd.read_csv(&#x27;.//testdata/demo1.csv&#x27;)print(pd.__class__) 1&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; xlsx文件 12df = pd.read_excel(&#x27;.//testdata/demo1.xlsx&#x27; )print(df.__class__) 1&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; 数据存储各类文件读取成为dataframe数据后可随意转存为其他格式的文件 12345678910df_cvs = pd.read_csv(&#x27;.//testdata/demo1.csv&#x27; )df_xlsx = pd.read_excel(&#x27;.//testdata/demo1.xlsx&#x27; )# csv读取的文件保存为csvdf_cvs.to_csv(&#x27;csv_to_csv.csv&#x27;)# excel读取的数据保存为exceldf_xlsx.to_excel(&#x27;xlsx_to_xlsx.xlsx&#x27;)# csv读取的数据保存为exceldf_cvs.to_excel(&#x27;csv_to_xlsx.xlsx&#x27;)# excel读取的数据保存为csvdf_xlsx.to_csv(&#x27;xlsx_to_csv.csv&#x27;) 创建测试对象创建一个20 × 5 的随机数的数据框(dataframe) 使用np生成矩阵的形式创建dataframe’ 12test_data = pd.DataFrame(np.random.randint(0, 20, size=(20, 5)))print(test_data) 直接输入生成 1234567df = pd.DataFrame(&#123;&quot;id&quot;:[1001,1002,1003,1004,1005,1006], &quot;date&quot;:pd.date_range(&#x27;20130102&#x27;, periods=6),&quot;city&quot;:[&#x27;Beijing &#x27;, &#x27;SH&#x27;, &#x27; guangzhou &#x27;, &#x27;Shenzhen&#x27;, &#x27;shanghai&#x27;, &#x27;BEIJING &#x27;],&quot;age&quot;:[23,44,54,32,34,32],&quot;category&quot;:[&#x27;100-A&#x27;,&#x27;100-B&#x27;,&#x27;110-A&#x27;,&#x27;110-C&#x27;,&#x27;210-A&#x27;,&#x27;130-F&#x27;],&quot;price&quot;:[1200,np.nan,2133,5433,np.nan,4432]&#125;,) 可在{}内数据内容后添加columns =[&#39;id&#39;,&#39;date&#39;,&#39;city&#39;,&#39;category&#39;,&#39;age&#39;,&#39;price&#39;],借此自定义dataframe内数据的列次序统计数据函数 df.info() :本函数提供dataframe的以下信息: RangeIndex:有多少数据 Data Columns:指定找到多少列 Columns:提供关于columns的信息 dtypes:提供dataframe内的数据类型 memory usage:表明内存使用量12test_data = pd.DataFrame(np.random.randint(0, 20, size=(20, 5)))print(test_data.info() 12345678910111213&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;RangeIndex: 20 entries, 0 to 19Data columns (total 5 columns):# Column Non-Null Count Dtype--- ------ -------------- -----0 0 20 non-null int321 1 20 non-null int322 2 20 non-null int323 3 20 non-null int324 4 20 non-null int32dtypes: int32(5)memory usage: 528.0 bytesNone df.shape 1print(test_data.shape) 1(20, 5) 类似于数组,shape作为属性,而非函数 df.index():显示找到的索引信息 1print(test_data.index) 1RangeIndex(start=0, stop=20, step=1) index作为属性 not callable df.count():给出每一列中有多少数据 1print(test_data.count()) 1234560 201 202 203 204 20dtype: int64 df.sum():给出每一列中的求和 1print(test_data.sum()) 1234560 2001 1192 2403 2144 204dtype: int64 df.sum():给出每一列中的求和 1print(test_data.sum()) 1234560 2001 1192 2403 2144 204dtype: int64 df.cumsum() 给出依次将每列前n行求和的结果 1print(test_data.cumsum()) 12345678910111213 id date city category age price0 1001 2013-01-02 Beijing 100-A 23 1200.01 1002 2013-01-03 SH 100-B 44 NaN2 1003 2013-01-04 guangzhou 110-A 54 2133.03 1004 2013-01-05 Shenzhen 110-C 32 5433.05 1006 2013-01-07 BEIJING 130-F 32 4432.0id date city category age price 0 1001 2013-01-02 Beijing 100-A 23 1200.0 1 2003 2056-01-05 Beijing SH 100-A100-B 67 NaN 2 3006 2099-01-08 Beijing SH guangzhou 100-A100-B110-A 121 3333.0 3 4010 2142-01-13 Beijing SH guangzhou Shenzhen 100-A100-B110-A110-C 153 8766.0 4 5015 2185-01-18 Beijing SH guangzhou Shenzhenshanghai 100-A100-B110-A110-C210-A 187 NaN 5 6021 2228-01-26 Beijing SH guangzhou ShenzhenshanghaiBEIJING 100-A100-B110-A110-C210-A130-F 219 13198.0 所得结果依然为dataframe 指定列时，只计算该列的累加值: tar = df[‘id’].cumsum() 不指定列时，则将返回各列的累加值 df.min():给出每列中的最小值 12345678id 1001date 2013-01-02 00:00:00city guangzhou category 100-Aage 23price 1200.0dtype: object &lt;class &#x27;pandas.core.series.Series&#x27;&gt; 所得结果为Series df.describe():函数提供了有关数据的基本统计信息（基于列计算）：count、mean、std、min、25%、50%、75%、max 12345678910 id age pricecount 6.000000 6.00000 4.000000mean 1003.500000 36.50000 3299.500000std 1.870829 10.87658 1966.638503min 1001.000000 23.00000 1200.00000025% 1002.250000 32.00000 1899.75000050% 1003.500000 33.00000 3282.50000075% 1004.750000 41.50000 4682.250000max 1006.000000 54.00000 5433.000000 &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.mean():给出每列中的均值 123456tar = df.mean()id 1003.5age 36.5price 3299.5dtype: float64&lt;class &#x27;pandas.core.series.Series&#x27;&gt; 只针对dataframe中的数字 df.median():给出每列中的中位数 df.quantlie([0.25, 0.75]):给出每列中的25% 和 75%的分位数 df.var()–方差值 df.std()–标准差值 df.cummin()–返回前n行的最小值 len(df):确定列的行数 len(df[‘columnId’]):返回某列的行数 df.count():返回Nan值个数 df.isnull():返回dataframe中各值是否为null return DataFrame df.corr():返回各列之间的相关系数 pandas中的选择与过滤 Series: mySeries[‘index’]–返回索引值为’index’的value df[n:N]–返回行n到N-1的dataframe 1tar =df[2:5] 12345id date city category age price2 1003 2013-01-04 guangzhou 110-A 54 2133.03 1004 2013-01-05 Shenzhen 110-C 32 5433.04 1005 2013-01-06 shanghai 210-A 34 NaN&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.head()–返回dataframe中的前几行,默认为5行 df.tail() df.sample()–随机选取几行,按频数 create filter–创建一个过滤条件 12filters = df.id &gt; 1003df[filter] 12343 1004 2013-01-05 Shenzhen 110-C 32 5433.04 1005 2013-01-06 shanghai 210-A 34 NaN5 1006 2013-01-07 BEIJING 130-F 32 4432.0 &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.filter(regex = ‘code’)–表示regex = ‘code’的列通过过滤条件 1tar = df.filter(regex=&#x27;date&#x27;).head() 1234567 date0 2013-01-021 2013-01-032 2013-01-043 2013-01-054 2013-01-06&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; np.logicl_and(filter1, filter2)–并行多个filter 1tar =df[np.logical_and(df[&#x27;id&#x27;] &gt; 1003, df[&#x27;age&#x27;] &gt; 33)] 14 1005 2013-01-06 shanghai 210-A 34 NaN df[(filter1) &amp; (filter2)] 1tar =df[(df[&#x27;id&#x27;] &gt; 1003) &amp; (df[&#x27;age&#x27;] &gt; 33)] sort data df.sort_values(‘columnName’, ascending=True) 对columnName列排序 ascending=true表示升序1df.sort_values(&#x27;age&#x27;, ascending=True) 123456789101112131415 id date city category age price0 1001 2013-01-02 Beijing 100-A 23 1200.01 1002 2013-01-03 SH 100-B 44 NaN2 1003 2013-01-04 guangzhou 110-A 54 2133.03 1004 2013-01-05 Shenzhen 110-C 32 5433.04 1005 2013-01-06 shanghai 210-A 34 NaN5 1006 2013-01-07 BEIJING 130-F 32 4432.0 id date city category age price0 1001 2013-01-02 Beijing 100-A 23 1200.03 1004 2013-01-05 Shenzhen 110-C 32 5433.05 1006 2013-01-07 BEIJING 130-F 32 4432.04 1005 2013-01-06 shanghai 210-A 34 NaN1 1002 2013-01-03 SH 100-B 44 NaN2 1003 2013-01-04 guangzhou 110-A 54 2133.0&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.sort_index() 对索引按照默认升序1df.sort_index() 12345### 重命名&amp;定义\\修改新的列1. df.rename(columns = &#123;&#x27;oldColumnName&#x27;:&#x27;newColumnName&#x27;&#125;) * 重命名 9 ```python tar = df.rename(columns = &#123;&#x27;id&#x27;:&#x27;newId&#x27;&#125;) df[‘newColume’] = newDesignWay 1df[&#x27;thisisanewcolumn&#x27;] = pd.Series(np.arange(0, 6, 1)) 1234567 id date city category age price thisisanewcolumn0 1001 2013-01-02 Beijing 100-A 23 1200.0 01 1002 2013-01-03 SH 100-B 44 NaN 12 1003 2013-01-04 guangzhou 110-A 54 2133.0 23 1004 2013-01-05 Shenzhen 110-C 32 5433.0 34 1005 2013-01-06 shanghai 210-A 34 NaN 45 1006 2013-01-07 BEIJING 130-F 32 4432.0 5 df.index.name = “index_name” 修改index为新index12345 ```4. df.columns = map(str.lower, df.columns) * 所有列名变大写字母 ```python df.columns = map(str.lower, df.columns) map()–python的内置函数,接受一个function,数个待迭代的list,使用function对list进行处理得到新的list,并不改变原list Drop Data df.drop(columns=[‘columnName’]) 指定删除某列数据1tar = df.drop(columns=[&#x27;Id&#x27;]) mySeries.drop([‘a’]) 指定删除索引值指向的value f.drop(‘Volume’, axis=1) 删除一个变量\\一个量1tar = df.drop(&#x27;Id&#x27;, axis=1) 转换数据类型 df.dtypes dataframe内各列的数据类型 df[‘columnName’] = df[‘columnName’].astype(‘dataType’) 转换指定行的数据类型1df[&#x27;Id&#x27;] = df[&#x27;Id&#x27;].astype(&#x27;float&#x27;) apply函数 方法1–自定义def函数 1234def examples(x): #create a functionreturn x*2df.Open.apply(examples).head() #use the function with apply() 自定义函数后,df.ColumnName获取df中需要使用此函数的列,再对此列使用apply函数,传入需要使用的函数 lambda函数 1df.Open.apply(lambda x: x*2).head() df.ColumnName获取df中需要使用此函数的列,再对此列使用lambda 声明数据处理方法","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"pandas","slug":"Python/pandas","permalink":"http://example.com/categories/Python/pandas/"}],"tags":[{"name":"Pandas","slug":"Pandas","permalink":"http://example.com/tags/Pandas/"}]}],"categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"},{"name":"Numpy","slug":"Python/Numpy","permalink":"http://example.com/categories/Python/Numpy/"},{"name":"Test","slug":"Test","permalink":"http://example.com/categories/Test/"},{"name":"tool","slug":"Python/tool","permalink":"http://example.com/categories/Python/tool/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"},{"name":"pandas","slug":"Python/pandas","permalink":"http://example.com/categories/Python/pandas/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://example.com/tags/Numpy/"},{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"},{"name":"Pandas","slug":"Pandas","permalink":"http://example.com/tags/Pandas/"}]}