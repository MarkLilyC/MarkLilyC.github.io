{"meta":{"title":"MarkLily","subtitle":"Tell me what you want,and i'll aviod it","description":"","author":"CJBLUE","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2021-07-07T13:29:05.000Z","updated":"2021-07-07T13:30:05.928Z","comments":true,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-06T13:14:11.000Z","updated":"2021-07-07T13:22:43.430Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2021-07-07T13:24:58.000Z","updated":"2021-07-07T13:26:28.584Z","comments":true,"path":"gallery/index.html","permalink":"http://example.com/gallery/index.html","excerpt":"","text":"melody background demo1 demo2 demo3 No title"},{"title":"tags","date":"2021-07-06T13:14:11.000Z","updated":"2021-07-07T13:18:53.168Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Pyhont-Tuple","slug":"ListAndTuple","date":"2021-07-07T07:55:24.000Z","updated":"2021-07-07T14:02:34.251Z","comments":true,"path":"2021/07/07/ListAndTuple/","link":"","permalink":"http://example.com/2021/07/07/ListAndTuple/","excerpt":"","text":"列表与元组 当元素类型不一时使用元组,当类型一样则使用列表 元组遍历更快 使用元组元素(不可变)可作为字典的键值,而列表不可 元组保证了数据的安全1 列表 – 2 元组-tuple元组类似于列表,但区别在于元组中的元素是不可变的 2.1 创建一个元组1. 使用()创建一个元组,使用,间隔元素2. 类似于列表,元组中的元素可以是任何数据类型 123&gt;&gt;&gt; tuple1 = (&#x27;aa&#x27;, 1, [1,2,3])&gt;&gt;&gt; print(tuple1, tuple1.__class__)(&#x27;aa&#x27;, 1, [1, 2, 3]) &lt;class &#x27;tuple&#x27;&gt; 因为元组不能改变,所以创建伊始就应该指定正确的元素 3. 创建元组时只指明一个元素(dtype A),则该元组(你意图创建的)会被视为A的对象 123456789101112# case1&gt;&gt;&gt; a = (&#x27;aa&#x27;)&gt;&gt;&gt; print(a.__class__)&lt;class &#x27;str&#x27;&gt;# case2&gt;&gt;&gt; b = ([1,2,3])&gt;&gt;&gt; print(b.__class__)&lt;class &#x27;list&#x27;&gt;# case3&gt;&gt;&gt; c = (1)&gt;&gt;&gt; print(c.__class__)&lt;class &#x27;int&#x27;&gt; case1-3中意图创建元组a b c,但创建时指指定了一个内部元素param(dtype A),因此该元组被视为A类的一个对象 2.2 访问元组元素2.2.1 索引-index[index:int]使用索引操作符来访问元组中的元素1. 正索引 : 0-len(tuple)-1 123&gt;&gt;&gt; tuple1 = (&#x27;aa&#x27;, 1, [1,2,3])&gt;&gt;&gt; print(tuple1[2])[1, 2, 3] 2. 负索引 2.2.2 切片:使用切片操作符 123&gt;&gt;&gt; tuple1 = (&#x27;aa&#x27;, 1, [1,2,3])&gt;&gt;&gt; print(tuple1[1:])(1, [1, 2, 3]) 方法1. enumerate(): 将元组内所有对象及其索引枚举,以元组的形式返回 12&gt;&gt;&gt; print(enumerate(tuple1).__class__)&lt;class &#x27;enumerate&#x27;&gt; 2. tuple(): 将序列（元组，字符串，字典）转换为元组 1234&gt;&gt;&gt; list1 = [1,2,&#x27;aa&#x27;,(1,2,3)]&gt;&gt;&gt; tp1 = tuple(list1)&gt;&gt;&gt; print(list1.__class__, tp1.__class__)&lt;class &#x27;list&#x27;&gt; &lt;class &#x27;tuple&#x27;&gt; 3. sorted: 返回一个排序元组 123&gt;&gt;&gt; tuplle1 = (2,2,3,0)&gt;&gt;&gt; print(sorted(tuplle1))[0, 2, 2, 3]","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Namespace","slug":"NameSpace","date":"2021-07-07T07:43:24.000Z","updated":"2021-07-07T14:02:28.957Z","comments":true,"path":"2021/07/07/NameSpace/","link":"","permalink":"http://example.com/2021/07/07/NameSpace/","excerpt":"","text":"命名空间及作用域1.命名空间1.1 命名空间（Namespace）1. 是从名称到对象的映射，一般通过字典实现2. 类似于c++ 1using namespace std 1.2 命名空间主要为了避免对象名称冲突1. 各个命名空间之间相互独立2. 命名空间内部不能有同名称对象3. 各个命名空间之间可以有相同名称对象 123# 如计算机内部文件夹之间的关系： * 单个文件夹内部不能有同名称元素 * 不同文件夹之间可以同名称元素 1.3 python一般有三种命名空间：内置-built in 局部(本地)-local 全局-global1.3.1 局部1. 局部空间包含:函数中定义的名称,记录了函数的变量,包括函数的参数与局部变量 此局部指的是此作用域,及其内部包含的对象 名称 2. locals():返回当前位置的全部局部变量 当前位置指的是当前locals()函数被调用的位置 全局内使用locals():所有有实例的函数 方法 lambda函式以及实现了__call__的,都会返回true12&gt;&gt;&gt; print(locals())&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;len&#x27;: &lt;function len at 0x00000186888145E8&gt;&#125; 此时的局部空间等于全局空间 函数内部使用locals():返回此函数空间内的所有名称及对象123456&gt;&gt;&gt; def len(param):... in_param = 2... print(locals())...&gt;&gt;&gt; len(4)&#123;&#x27;param&#x27;: 4, &#x27;in_param&#x27;: 2&#125; 循环内使用locals(): 12345&gt;&gt;&gt; for i in [1,2]:... print(locals())...&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;i&#x27;: 1&#125;&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;i&#x27;: 2&#125; 证明for循环不算一个单独的作用域 1.3.2 全局1. 全局空间包含:模块中定义的名称,记录了模块的变量,包括函数 类 导入模块 可理解为此.py文件所代表的空间 2. globals():返回当前全局空间内的名称及对象 全局内使用globals():12&gt;&gt;&gt; print(globals())&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;i&#x27;: 2&#125; 全局命名空间里包括了整个模块内的命名名称，比如变量 x y 函数名,而且还包括了一些内置的变量命名，比如 __name__ __file__等等。 全局空间与全局使用局部空间相同:123456&gt;&gt;&gt; if locals() == globals():... print(&#x27;yes&#x27;)... else:... print(&#x27;no&#x27;)...yes 1.3.3 内置1. 内置空间包含:python语言的内置名称,如函数名abs char等1.4 各空间关系1. 命名空间使用顺序:局部-&gt;全局-&gt;内置 这样可以完成对全局 内置函数的’’改写’’:12345&gt;&gt;&gt; def len(param):... print(param)...&gt;&gt;&gt; len([1,2,3,4])[1, 2, 3, 4] python内置此方法的输出为元素长度:12&gt;&gt;&gt; print(len([1,2,3,4]))[1, 2, 3, 4] 当无法找到此名称的对象时,则抛出异常命名空间的生命周期命名空间的声明周期却决与该变量的作用域,对象执行完成,则该命名空间的生命周期结束2. 作用域2.1 作用域1. 作用域:访问某变量 对象的区域 每个对象都存在特定的作用域中 作用时段中 当前程序未执行到该作用域,则某些只存在于该作用域的对象则不能被访问 或者说,只有被赋值且未该赋值区域未完成其全部功能时,该对象才能被访问 简单来说就是:该对象在未赋值时,不能被访问;使用结束跳出该域后也不能访问 2.2 作用域分类2.2.1 L-local 局部作用域2.2.2 E-encloing scope 闭包函数作用域,嵌套函数(A(B(var c)))中var c所在作用域2.2.3 G=global2.2.4 B-built in1. 内置作用域的实现是通过builtin标准模块实现 但是此变量名本身并未放入内置作用域,需要导入模块才能使用2. builtin 12&gt;&gt;&gt; import builtins&gt;&gt;&gt; dir(builtins) 2.3 规则1. 当在函数中引用一个变量的时候，以上的作用域顺序也是 Python 搜索的一个顺序 L-&gt;E-G-B，首先尝试局部作用域，没找到的话，继续搜索闭包函数作用域，然后再是全局作用域和内置作用域。2. Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域 其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问(如1.3.1.2) 如:12345&gt;&gt;&gt; if True:... testStr = &#x27;this is a testline to test if this is a new region&#x27;...&gt;&gt;&gt; print(testStr)this is a testline to test if this is a new region","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Pyhont-Set","slug":"Set","date":"2021-07-07T07:40:24.000Z","updated":"2021-07-07T14:04:40.407Z","comments":true,"path":"2021/07/07/Set/","link":"","permalink":"http://example.com/2021/07/07/Set/","excerpt":"","text":"集合-set集合的基本性质:1. 集合包含了不重复且无序的元素2. 集合是可变数据类型 但是其内部元素必须是不可变数据类型,即元组可以作为其元素,但是列表 集合 字典不能作为其元素 1234&gt;&gt;&gt; c = &#123;1,2,3,[1,2]&#125;Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: &#x27;list&#x27; 1. 创建集合 使用&#123;&#125;创建集合,内部元素使用,分隔 使用python内置函数set()1234&gt;&gt;&gt; a = &#123;1,2,3,tuplle1&#125;&gt;&gt;&gt; b = set([1,3,&#x27;SS&#x27;,tuplle1])&gt;&gt;&gt; print(a.__class__, b.__class__)&lt;class &#x27;set&#x27;&gt; &lt;class &#x27;set&#x27;&gt; 2. 修改集合 不能通过索引 切片操作来访问其中的元素,因为集合是无序的2.1 添加元素1. add()方法添加单个元素2. update()方法添加多个元素12345678&gt;&gt;&gt; a = &#123;1,2,3,tuplle1&#125;&gt;&gt;&gt; a.add(&#x27;aa&#x27;)&gt;&gt;&gt; print(a)&gt;&gt;&gt; a = &#123;1,2,3&#125;&gt;&gt;&gt; a.update([2,4])&gt;&gt;&gt; print(a)&#123;1, 2, 3, 4&#125; 集合内不重复的性质会自动去掉update()参数中的重复元素 2.2 删除元素1. discard()2. remove()12345678910111213&gt;&gt;&gt; a.discard(2)&gt;&gt;&gt; print(a)&#123;1, 3, 4&#125;&gt;&gt;&gt; a.remove(1)&gt;&gt;&gt; print(a)&#123;3, 4&#125;&gt;&gt;&gt; a.discard(10)&gt;&gt;&gt; a.remove(11)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 11 二者差别在于,当被去除元素不存在时,discard不会报错,remove报错 3. pop():去掉任意一个元素 12&gt;&gt;&gt; a.pop()3 4. clear() 清空结合 1234567&gt;&gt;&gt; a.update([1,2,3,4,5,6,7,9])&gt;&gt;&gt; print(a)&#123;1, 2, 3, 4, 5, 6, 7, 9&#125;&gt;&gt;&gt; a.clear()&gt;&gt;&gt; print(a)set() 2.3 集合的逻辑操作1. &amp; / intersection – 交集 123456789&gt;&gt;&gt; x = &#123;1, 2, 3, 4, 5, 6&#125;&gt;&gt;&gt; y = &#123;7, 8, 9, 10, 11, 12&#125;&gt;&gt;&gt; print(x&amp;y)set()&gt;&gt;&gt; print(x.intersection(y))set()&gt;&gt;&gt; x.update([7,8,9])&gt;&gt;&gt; print(x.intersection(y))&#123;8, 9, 7&#125; 当二者无交集,则返回空set 2. - / difference – 差集:只在其一集合中出现 123456x = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;y = &#123;7, 8, 9, 10, 11, 12&#125;&gt;&gt;&gt; print(x-y)&#123;1, 2, 3, 4, 5, 6&#125;&gt;&gt;&gt; print(x.difference(y))&#123;1, 2, 3, 4, 5, 6&#125; 3. ^ / symmetric_difference – 对称差集:不同时出现在两个集合的元素 12&gt;&gt;&gt; print(x^y, x.symmetric_difference(y))&#123;1, 2, 3, 4, 5, 6, 10, 11, 12&#125; &#123;1, 2, 3, 4, 5, 6, 10, 11, 12&#125; 4. union() – 求并集 3 不可变集合 由于集合的元素可变,所以无法作为字典的键值 采用frozenset()可以创建不可变元素的不可变集合 123&gt;&gt;&gt; a = frozenset(&#123;1,2,3&#125;)&gt;&gt;&gt; print(a)frozenset(&#123;1, 2, 3&#125;)","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Pyhont-Class","slug":"Class","date":"2021-07-07T07:33:24.000Z","updated":"2021-07-07T14:02:52.444Z","comments":true,"path":"2021/07/07/Class/","link":"","permalink":"http://example.com/2021/07/07/Class/","excerpt":"","text":"类–CLASS类 我的泪 学java的时候搞得很清楚的 操 现在忘干净了 python中的类与对象","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Pyhont-Array","slug":"Array","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-07T14:02:49.372Z","comments":true,"path":"2021/07/07/Array/","link":"","permalink":"http://example.com/2021/07/07/Array/","excerpt":"","text":"数组-array数组的基本性质: 数组本身不属于基本数据类型,需要导入array使用数组 数组内部元素类型相同 数组不同于列表:内部元素相同,列表内部元素可以不同 人如其名,内部元素只能是数字数组定义 声明一个数组,必须遵循基本语法:arrayName = array(typecode, [initializers]): typecode:str 123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,2,3,4])&gt;&gt;&gt; print(arr1, arr1.__class__)array(&#x27;i&#x27;, [1, 2, 3, 4]) &lt;class &#x27;array.array&#x27;&gt; 当声明数据类型与initializers数据类型不一,则报错: 1234&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,2.2,3,4])Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: integer argument expected, got float 指定数据类型后,initializers可为空: 123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[])&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;) 访问数组索引–[]123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,3,4,5,6,7,5])&gt;&gt;&gt; print(arr1[1])3 切片–:12&gt;&gt;&gt; print(arr1[1:])array(&#x27;i&#x27;, [3, 4, 5, 6, 7, 5]) index(x)返回首次出现x的最小索引123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,3,4,5,6,7,5])&gt;&gt;&gt; print(arr1.index(5))3 负索引修改数组append()将一个元素添加到数组末尾1234&gt;&gt;&gt; a = array(&#x27;i&#x27;, [1,2,3,4,5,7,8,9])&gt;&gt;&gt; a.append(10)&gt;&gt;&gt; print(a)array(&#x27;i&#x27;, [1, 2, 3, 4, 5, 7, 8, 9, 10]) insert(x, i)将元素x指定添加到i处1234&gt;&gt;&gt; a = array(&#x27;i&#x27;, [1,2,3])&gt;&gt;&gt; a.insert(1, 22)&gt;&gt;&gt; print(a)array(&#x27;i&#x27;, [1, 22, 2, 3]) extend(x)将x元素添加到数组,若x时数组,则二者应有相同的数据类型12345&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;, [1,2,3])&gt;&gt;&gt; arr2 = array(&#x27;i&#x27;, [3,4,5])&gt;&gt;&gt; arr1.extend(arr2)&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [1, 2, 3, 3, 4, 5]) fromlist()将list中的元素添加到数组中12345&gt;&gt;&gt; a = array(&#x27;i&#x27;, [1,2,3,4,5,7,8,9])&gt;&gt;&gt; l = [10,11]&gt;&gt;&gt; a.fromlist(l)&gt;&gt;&gt; print(a)array(&#x27;i&#x27;, [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]) reverse()反转数组12345678910&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [1, 2, 3, 3, 4, 5])&gt;&gt;&gt; print(arr1.reverse())None&gt;&gt;&gt; arr1.reverse()&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [1, 2, 3, 3, 4, 5])&gt;&gt;&gt; arr1.reverse()&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [5, 4, 3, 3, 2, 1]) +将两个数组拼接12&gt;&gt;&gt; print(arr1 + arr2)array(&#x27;i&#x27;, [5, 4, 3, 3, 2, 1, 3, 4, 5]) *将数组复制添加到本身12&gt;&gt;&gt; print(arr1*2)array(&#x27;i&#x27;, [5, 4, 3, 3, 2, 1, 5, 4, 3, 3, 2, 1]) del arr[i]删除某个元素,或数组12345&gt;&gt;&gt; arr1array(&#x27;i&#x27;, [4, 3, 3, 2, 1])&gt;&gt;&gt; del arr1[0]&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [3, 3, 2, 1]) 12345&gt;&gt;&gt; del arr1&gt;&gt;&gt; print(arr1)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;arr1&#x27; is not defined remove()从数组中删除第一个出现的x元素12345&gt;&gt;&gt; arr2array(&#x27;i&#x27;, [3, 4, 5, 3, 4, 5])&gt;&gt;&gt; arr2.remove(3)&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 3, 4, 5]) pop()删除并返回数组的最后一个元素12345&gt;&gt;&gt; arr2array(&#x27;i&#x27;, [3, 4, 5, 3, 4, 5])&gt;&gt;&gt; arr2.remove(3)&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 3, 4, 5]) 也可指定pop对象索引123456&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 3, 4])&gt;&gt;&gt; arr2.pop(2)3&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 4])","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Numpy100","slug":"numpy/numpy100","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-07T14:06:44.158Z","comments":true,"path":"2021/07/07/numpy/numpy100/","link":"","permalink":"http://example.com/2021/07/07/numpy/numpy100/","excerpt":"","text":"github上的开源项目2021.7.4 17：06 cj at swjtu jiuli campus创建一个长度为10的空向量12z = np.zeros(10)print(z) 找到数组的内存大小12z = np.zeros(10)print(z.size * z.itermsize) z.size获取到内部的元素个数z.itemsize获取到各个元素的大小 从命令行对得到相关函数的说明文档1print(np.info(np.add)) 创建一个长度为10,且除了第五个元素为1的空向量123z = np.zeros(10)z[4] = 1print(z) 创建值域10-49的向量1z = np.arange(10, 50) 反转一个向量1234z = np.arange(0, 5)print(z)z = z[::-1]print(z) b = [0 1 2 3 4]a = b[x : y]: 两索引各自计算,正值从左侧开始,负值从右侧开始 左侧索引元素在右侧索引元素左侧,则返回非空 某侧无索引则代表,从另一侧索引顺方向计数完 a为两侧索引之内交集元素返回的array 若两侧索引之内无元素,则a为空array a = b[4:2] : a = []a = b[-3:4] : a = []a = b[4:-2] : a = [] x&gt;0 y&gt;0 a = b[x:y]: a = x-y内元素返回array a = b[ :y]: a = 0-y内元素返回 a = b[x: ]: a = x-len(b)内元素返回 x &lt; y : a = [] x&lt;0 or y&lt;0 a = b[-4:-1]: a = b中-4号元素到-1号元素返回 a = b[-4:1]: a = [] a = b[-4:]: a = -4 - 0索引之间元素返回 a = b[:-4]: a = [] a = b[3:-4]: a = [] a = b[::a] 在b中没隔a取一个元素返回a 取值方向由a正负决定 创建一个3 * 3,值域:0-8的矩阵12z = np.arange(0,9).reshape(3,3)print(z) 找到数组中的0元素索引12z = np.array([0, 1, 0, 3, 4, 0])print(z.nonzero()) 创建一个3 * 3的单位矩阵12z = np.eye(3)print(z) 创建一个3 * 3的随机数据123from numpy import randomz = np.random.random((3, 3, 3))print(z) 创建一个10 * 10的随机数组,并获取最小与最大值123from numpy import randomz = np.random.random((10, 10))print(z.min(), z.max()) 创建一个长度为30的随机向量,并获取其平均值1234from numpy import randomz = np.random.random((30))zMean = z.mean()print(zMean) 创建一个二维数组,其边界值为1,其余值为0123z = np.ones((6, 6))z[1:-1, 1:-1] = 0print(z) 其原理是:用array[a:b,c:d] = x进行对二维数组赋值的方式 array[1:-1,1:-1] = x其原理类似a = b[1:-1]从行索引为从第一行到-1行(及倒是第二行),这样根据每个array的大小去调整参数 对于一个存在的数组,如何用0填充其边界123z = np.ones((6, 6))z = np.pad(z, pad_width=1, mode=&#x27;constant&#x27;, constant_values=0)print(z) 下列各式的运行结果 0 * np.nan –&gt; nan np.nan==np.nan –&gt; False np.inf &gt; np.nan –&gt; False np.nan - np.nan –&gt; nan 0.3 == 3 * 0.1 –&gt; False nan 不是数字,是不存在 inf infinite 创建一个5 * 5的矩阵,并设置1 2 3 4落在其对角线的下方12Z = np.diag(1+np.arange(4), k = -1)print(Z) np.diag(array_like, k) 返回此array第k位置对角线的矩阵 当只传入矩阵,则返回此矩阵的对角线元素","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"Numpy","slug":"Python/Numpy","permalink":"http://example.com/categories/Python/Numpy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://example.com/tags/Numpy/"}]},{"title":"Pyhont-ArrDictionaryay","slug":"dictionary","date":"2021-07-07T07:02:24.000Z","updated":"2021-07-07T14:02:39.861Z","comments":true,"path":"2021/07/07/dictionary/","link":"","permalink":"http://example.com/2021/07/07/dictionary/","excerpt":"","text":"字典-Dictionary字典的基本性质: 字典是python的内置数据类型 字典的数据是键值对一一对应,根据键索引指定值创建字典1. 使用&#123;&#125;创建字典,声明其类型 字典键是不可变数据类型,用元组或不可变集合创建 字典值是可变数据类型12345&gt;&gt;&gt; dict1 = &#123;1:&#x27;value1&#x27;, &#x27;key2&#x27;:&#x27;value2&#x27;&#125;&gt;&gt;&gt; print(type(dict1))&lt;class &#x27;dict&#x27;&gt;&gt;&gt;&gt; print(dict1[1])value1 键只能是不可变数据类型:元组 不可变集合值都可 123&gt;&gt;&gt; dict1 = &#123;tp1:tp1&#125;&gt;&gt;&gt; print(dict1, dict1.__class__)&#123;(3, 2, 11): (3, 2, 11)&#125; &lt;class &#x27;dict&#x27;&gt; 2. 使用dict()初始化字典 12345&gt;&gt;&gt; d&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[2]&#x27;Pink&#x27; 访问字典键12345678&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[2]&#x27;Pink&#x27;&gt;&gt;&gt; d[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 3 []索引找不到值则报错 get()123456789101112131415&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[2]&#x27;Pink&#x27;&gt;&gt;&gt; d[1]&#x27;Blue&#x27;&gt;&gt;&gt; d.get(1)&#x27;Blue&#x27;&gt;&gt;&gt; d[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 3&gt;&gt;&gt; d.get(3)&gt;&gt;&gt; print(d.get(3))None 当.get()方法找不到值,则返回None 更新值使用键定位,更新值 12345&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[1] = &#x27;cjblue&#x27;&gt;&gt;&gt; print(d)&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;&#125; 直接使用新键,则添加新值 12345&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[5] = &#x27;marklily&#x27;&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;, 5: &#x27;marklily&#x27;&#125; 删除元素1. pop() 删除并返回给定键的值 123456&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;, 5: &#x27;marklily&#x27;&#125;&gt;&gt;&gt; d.pop(2)&#x27;Pink&#x27;&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;&#125; 2. popitem() 删除并返回任意一个键值对 123456&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;, 3: &#x27;floyd&#x27;&#125;&gt;&gt;&gt; d.popitem()(3, &#x27;floyd&#x27;)&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;&#125; 3. clear() 删除所有元素但不删除字典本身 123&gt;&gt;&gt; d.clear()&gt;&gt;&gt; d&#123;&#125; 4. del 删除特定键值对或删除整个字典 12345678910&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;, 3: &#x27;floyd&#x27;&#125;&gt;&gt;&gt; del d[1]&gt;&gt;&gt; d&#123;5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;, 3: &#x27;floyd&#x27;&#125;&gt;&gt;&gt; del d&gt;&gt;&gt; dTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;d&#x27; is not defined","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Pyhont-Recursion","slug":"Recursion","date":"2021-07-07T05:40:24.000Z","updated":"2021-07-07T14:02:16.777Z","comments":true,"path":"2021/07/07/Recursion/","link":"","permalink":"http://example.com/2021/07/07/Recursion/","excerpt":"","text":"递归举例计算阶乘 12345678910&gt;&gt;&gt; def cal(n):... if n == 1:... return 1... else:... return n * cal(n - 1)...&gt;&gt;&gt; print(cal(4))24&gt;&gt;&gt; print(cal(6))720 递归函数内部会调用函数本身 某次调用递归函数时,内部调用本身时会指定参数 在递归函数中,应有一个结束参数信号,在每次递归中,参数不断靠近该信号递归次数限制python递归次数限制为3000次,超出此次数则会触发RecursionError移除递归次数限制sys.setrecursionlimit(5000) 设置次数限制为我们所需要的次数","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Pandas-basic","slug":"PandasNotes","date":"2021-07-07T02:40:24.000Z","updated":"2021-07-07T14:02:23.709Z","comments":true,"path":"2021/07/07/PandasNotes/","link":"","permalink":"http://example.com/2021/07/07/PandasNotes/","excerpt":"","text":"2142Pandas数据结构pandas有两种数据结构：Series and dataframe数据框 SeriesSeries是一个一维标记数组，可以存储任何种类的数据 12my_series = pd.Series([3,-5,7,4], index=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])print(my_series) 12345a 3b -5c 7d 4dtype: int64 Series中的数据可通过index找到 1print(my_series[&#x27;d&#x27;]) 14 series类似于字典(当然这只是个人直观感受) dataframe是一个二维数据结构,包含不同的列 12345678data = &#123; &#x27;Country&#x27; : [&#x27;Belgium&#x27;, &#x27;India&#x27;, &#x27;Brazil&#x27; ], &#x27;Capital&#x27;: [&#x27;Brussels&#x27;, &#x27;New Delhi&#x27;, &#x27;Brassilia&#x27;], &#x27;Population&#x27;: [1234,1234,1234]&#125;datas = pd.DataFrame(data, columns=[&#x27;Country&#x27;,&#x27;Capital&#x27;,&#x27;Population&#x27;])print(type(data))print(type(datas))print(datas) 123456&lt;class &#x27;dict&#x27;&gt;&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;Country Capital Population0 Belgium Brussels 12341 India New Delhi 12342 Brazil Brassilia 1234 创建dataframe时,在写入或打印时会自动生成从第一行正式数据开始的行序号 and 第一列正式数据开始的列序号dataframe类似于数组,可直接使用行列序号进行访问具体的数据 调用/读取数据 CSV文件 12pd = pd.read_csv(&#x27;.//testdata/demo1.csv&#x27;)print(pd.__class__) 1&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; xlsx文件 12df = pd.read_excel(&#x27;.//testdata/demo1.xlsx&#x27; )print(df.__class__) 1&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; 数据存储各类文件读取成为dataframe数据后可随意转存为其他格式的文件 12345678910df_cvs = pd.read_csv(&#x27;.//testdata/demo1.csv&#x27; )df_xlsx = pd.read_excel(&#x27;.//testdata/demo1.xlsx&#x27; )# csv读取的文件保存为csvdf_cvs.to_csv(&#x27;csv_to_csv.csv&#x27;)# excel读取的数据保存为exceldf_xlsx.to_excel(&#x27;xlsx_to_xlsx.xlsx&#x27;)# csv读取的数据保存为exceldf_cvs.to_excel(&#x27;csv_to_xlsx.xlsx&#x27;)# excel读取的数据保存为csvdf_xlsx.to_csv(&#x27;xlsx_to_csv.csv&#x27;) 创建测试对象创建一个20 × 5 的随机数的数据框(dataframe) 使用np生成矩阵的形式创建dataframe’ 12test_data = pd.DataFrame(np.random.randint(0, 20, size=(20, 5)))print(test_data) 直接输入生成 1234567df = pd.DataFrame(&#123;&quot;id&quot;:[1001,1002,1003,1004,1005,1006], &quot;date&quot;:pd.date_range(&#x27;20130102&#x27;, periods=6),&quot;city&quot;:[&#x27;Beijing &#x27;, &#x27;SH&#x27;, &#x27; guangzhou &#x27;, &#x27;Shenzhen&#x27;, &#x27;shanghai&#x27;, &#x27;BEIJING &#x27;],&quot;age&quot;:[23,44,54,32,34,32],&quot;category&quot;:[&#x27;100-A&#x27;,&#x27;100-B&#x27;,&#x27;110-A&#x27;,&#x27;110-C&#x27;,&#x27;210-A&#x27;,&#x27;130-F&#x27;],&quot;price&quot;:[1200,np.nan,2133,5433,np.nan,4432]&#125;,) 可在{}内数据内容后添加columns =[&#39;id&#39;,&#39;date&#39;,&#39;city&#39;,&#39;category&#39;,&#39;age&#39;,&#39;price&#39;],借此自定义dataframe内数据的列次序统计数据函数 df.info() :本函数提供dataframe的以下信息: RangeIndex:有多少数据 Data Columns:指定找到多少列 Columns:提供关于columns的信息 dtypes:提供dataframe内的数据类型 memory usage:表明内存使用量12test_data = pd.DataFrame(np.random.randint(0, 20, size=(20, 5)))print(test_data.info() 12345678910111213&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;RangeIndex: 20 entries, 0 to 19Data columns (total 5 columns):# Column Non-Null Count Dtype--- ------ -------------- -----0 0 20 non-null int321 1 20 non-null int322 2 20 non-null int323 3 20 non-null int324 4 20 non-null int32dtypes: int32(5)memory usage: 528.0 bytesNone df.shape 1print(test_data.shape) 1(20, 5) 类似于数组,shape作为属性,而非函数 df.index():显示找到的索引信息 1print(test_data.index) 1RangeIndex(start=0, stop=20, step=1) index作为属性 not callable df.count():给出每一列中有多少数据 1print(test_data.count()) 1234560 201 202 203 204 20dtype: int64 df.sum():给出每一列中的求和 1print(test_data.sum()) 1234560 2001 1192 2403 2144 204dtype: int64 df.sum():给出每一列中的求和 1print(test_data.sum()) 1234560 2001 1192 2403 2144 204dtype: int64 df.cumsum() 给出依次将每列前n行求和的结果 1print(test_data.cumsum()) 12345678910111213 id date city category age price0 1001 2013-01-02 Beijing 100-A 23 1200.01 1002 2013-01-03 SH 100-B 44 NaN2 1003 2013-01-04 guangzhou 110-A 54 2133.03 1004 2013-01-05 Shenzhen 110-C 32 5433.05 1006 2013-01-07 BEIJING 130-F 32 4432.0id date city category age price 0 1001 2013-01-02 Beijing 100-A 23 1200.0 1 2003 2056-01-05 Beijing SH 100-A100-B 67 NaN 2 3006 2099-01-08 Beijing SH guangzhou 100-A100-B110-A 121 3333.0 3 4010 2142-01-13 Beijing SH guangzhou Shenzhen 100-A100-B110-A110-C 153 8766.0 4 5015 2185-01-18 Beijing SH guangzhou Shenzhenshanghai 100-A100-B110-A110-C210-A 187 NaN 5 6021 2228-01-26 Beijing SH guangzhou ShenzhenshanghaiBEIJING 100-A100-B110-A110-C210-A130-F 219 13198.0 所得结果依然为dataframe 指定列时，只计算该列的累加值: tar = df[‘id’].cumsum() 不指定列时，则将返回各列的累加值 df.min():给出每列中的最小值 12345678id 1001date 2013-01-02 00:00:00city guangzhou category 100-Aage 23price 1200.0dtype: object &lt;class &#x27;pandas.core.series.Series&#x27;&gt; 所得结果为Series df.describe():函数提供了有关数据的基本统计信息（基于列计算）：count、mean、std、min、25%、50%、75%、max 12345678910 id age pricecount 6.000000 6.00000 4.000000mean 1003.500000 36.50000 3299.500000std 1.870829 10.87658 1966.638503min 1001.000000 23.00000 1200.00000025% 1002.250000 32.00000 1899.75000050% 1003.500000 33.00000 3282.50000075% 1004.750000 41.50000 4682.250000max 1006.000000 54.00000 5433.000000 &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.mean():给出每列中的均值 123456tar = df.mean()id 1003.5age 36.5price 3299.5dtype: float64&lt;class &#x27;pandas.core.series.Series&#x27;&gt; 只针对dataframe中的数字 df.median():给出每列中的中位数 df.quantlie([0.25, 0.75]):给出每列中的25% 和 75%的分位数 df.var()–方差值 df.std()–标准差值 df.cummin()–返回前n行的最小值 len(df):确定列的行数 len(df[‘columnId’]):返回某列的行数 df.count():返回Nan值个数 df.isnull():返回dataframe中各值是否为null return DataFrame df.corr():返回各列之间的相关系数 pandas中的选择与过滤 Series: mySeries[‘index’]–返回索引值为’index’的value df[n:N]–返回行n到N-1的dataframe 1tar =df[2:5] 12345id date city category age price2 1003 2013-01-04 guangzhou 110-A 54 2133.03 1004 2013-01-05 Shenzhen 110-C 32 5433.04 1005 2013-01-06 shanghai 210-A 34 NaN&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.head()–返回dataframe中的前几行,默认为5行 df.tail() df.sample()–随机选取几行,按频数 create filter–创建一个过滤条件 12filters = df.id &gt; 1003df[filter] 12343 1004 2013-01-05 Shenzhen 110-C 32 5433.04 1005 2013-01-06 shanghai 210-A 34 NaN5 1006 2013-01-07 BEIJING 130-F 32 4432.0 &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.filter(regex = ‘code’)–表示regex = ‘code’的列通过过滤条件 1tar = df.filter(regex=&#x27;date&#x27;).head() 1234567 date0 2013-01-021 2013-01-032 2013-01-043 2013-01-054 2013-01-06&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; np.logicl_and(filter1, filter2)–并行多个filter 1tar =df[np.logical_and(df[&#x27;id&#x27;] &gt; 1003, df[&#x27;age&#x27;] &gt; 33)] 14 1005 2013-01-06 shanghai 210-A 34 NaN df[(filter1) &amp; (filter2)] 1tar =df[(df[&#x27;id&#x27;] &gt; 1003) &amp; (df[&#x27;age&#x27;] &gt; 33)] sort data df.sort_values(‘columnName’, ascending=True) 对columnName列排序 ascending=true表示升序1df.sort_values(&#x27;age&#x27;, ascending=True) 123456789101112131415 id date city category age price0 1001 2013-01-02 Beijing 100-A 23 1200.01 1002 2013-01-03 SH 100-B 44 NaN2 1003 2013-01-04 guangzhou 110-A 54 2133.03 1004 2013-01-05 Shenzhen 110-C 32 5433.04 1005 2013-01-06 shanghai 210-A 34 NaN5 1006 2013-01-07 BEIJING 130-F 32 4432.0 id date city category age price0 1001 2013-01-02 Beijing 100-A 23 1200.03 1004 2013-01-05 Shenzhen 110-C 32 5433.05 1006 2013-01-07 BEIJING 130-F 32 4432.04 1005 2013-01-06 shanghai 210-A 34 NaN1 1002 2013-01-03 SH 100-B 44 NaN2 1003 2013-01-04 guangzhou 110-A 54 2133.0&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.sort_index() 对索引按照默认升序1df.sort_index() 12345### 重命名&amp;定义\\修改新的列1. df.rename(columns = &#123;&#x27;oldColumnName&#x27;:&#x27;newColumnName&#x27;&#125;) * 重命名 9 ```python tar = df.rename(columns = &#123;&#x27;id&#x27;:&#x27;newId&#x27;&#125;) df[‘newColume’] = newDesignWay 1df[&#x27;thisisanewcolumn&#x27;] = pd.Series(np.arange(0, 6, 1)) 1234567 id date city category age price thisisanewcolumn0 1001 2013-01-02 Beijing 100-A 23 1200.0 01 1002 2013-01-03 SH 100-B 44 NaN 12 1003 2013-01-04 guangzhou 110-A 54 2133.0 23 1004 2013-01-05 Shenzhen 110-C 32 5433.0 34 1005 2013-01-06 shanghai 210-A 34 NaN 45 1006 2013-01-07 BEIJING 130-F 32 4432.0 5 df.index.name = “index_name” 修改index为新index12345 ```4. df.columns = map(str.lower, df.columns) * 所有列名变大写字母 ```python df.columns = map(str.lower, df.columns) map()–python的内置函数,接受一个function,数个待迭代的list,使用function对list进行处理得到新的list,并不改变原list Drop Data df.drop(columns=[‘columnName’]) 指定删除某列数据1tar = df.drop(columns=[&#x27;Id&#x27;]) mySeries.drop([‘a’]) 指定删除索引值指向的value f.drop(‘Volume’, axis=1) 删除一个变量\\一个量1tar = df.drop(&#x27;Id&#x27;, axis=1) 转换数据类型 df.dtypes dataframe内各列的数据类型 df[‘columnName’] = df[‘columnName’].astype(‘dataType’) 转换指定行的数据类型1df[&#x27;Id&#x27;] = df[&#x27;Id&#x27;].astype(&#x27;float&#x27;) apply函数 方法1–自定义def函数 1234def examples(x): #create a functionreturn x*2df.Open.apply(examples).head() #use the function with apply() 自定义函数后,df.ColumnName获取df中需要使用此函数的列,再对此列使用apply函数,传入需要使用的函数 lambda函数 1df.Open.apply(lambda x: x*2).head() df.ColumnName获取df中需要使用此函数的列,再对此列使用lambda 声明数据处理方法","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"pandas","slug":"Python/pandas","permalink":"http://example.com/categories/Python/pandas/"}],"tags":[{"name":"Pandas","slug":"Pandas","permalink":"http://example.com/tags/Pandas/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"},{"name":"Numpy","slug":"Python/Numpy","permalink":"http://example.com/categories/Python/Numpy/"},{"name":"pandas","slug":"Python/pandas","permalink":"http://example.com/categories/Python/pandas/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://example.com/tags/Numpy/"},{"name":"Pandas","slug":"Pandas","permalink":"http://example.com/tags/Pandas/"}]}