{"meta":{"title":"MarkLily","subtitle":"Tell me what you want,and i'll aviod it","description":"","author":"CJBLUE","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2020-02-23T11:20:33.000Z","updated":"2021-07-10T15:46:54.667Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"CJBLUE_MarkLilyCJBLUEbluesMediumSlateBlueSlateBlueDarkSlateBlueBlueMediumBlueMidnightBlueDarkBlueNavyRoyalBlueCornflowerBlueLightSteelBlueLightSlateGrayDodgerBlueAliceBlueSteelBlueLightSkyBlueSkyBlueDeepSkyBlueLightBluePowderBlueAzure是音乐MarkLily 他是Department of Integration (DOI)的社会工作人员.他是魔女Callie Maggotbone的男朋友，也是僵尸Randall 和巫师Leonard 的朋友.马克究竟有多高尚不得而知，但大多数时候他都比 6 英尺 2 英寸的格莱姆斯高一点. MusicGuns and roses the Beatles the rolling stones the libertines galaxies 500 Oasis Pink Floyd Arctic Monkeys DarkBlue Dire Straits Lynyrd Skynyrd Deep Purple A vengen Sevenfold Baby shambles Blondie David Bowie pixies Fun. Joy Division Led Zeppelin Mansun Peter Doherty the stone roses Sonic Youth the verve Violent Femmes"}],"posts":[{"title":"git-05-撤销修改","slug":"git/git-05-撤销修改","date":"2021-07-13T02:53:22.000Z","updated":"2021-07-17T02:33:48.269Z","comments":true,"path":"2021/07/13/git/git-05-撤销修改/","link":"","permalink":"http://example.com/2021/07/13/git/git-05-%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9/","excerpt":"撤销修改可大致分为：从工作区撤销 从暂存区撤销以及版本库回退","text":"撤销修改可大致分为：从工作区撤销 从暂存区撤销以及版本库回退 hexo 基本命令 上一节后我们的test.txt文件内容为this is a test txtfile, 且已提交到了版本库 为方便演示, 我们现在再对其增加一行: add a line to test recall 最终此文件内容为 : 12this is a test txtfileadd a line to test recall 撤销工作区内文件的修改基于以上修改, 我们不做任何提交 查看工作区状态12345678$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 提示我们使用git restore &lt;file&gt;...-撤销工作区的修改 修改前,进入test.txt文件查看文件内容12this is a test textnew line1 确认此时文件处于工作区并已修改 使用git restore撤销修改1$ git restore test.txt 进入test.txt文件查看文件内容1this is a test txtfile 说明对文件的修改已被撤销 查看工作区状态123$ git statusOn branch masternothing to commit, working tree clean 工作树呈现clean,说明文本之前的修改信息被删除,以及此次撤销修改也不被日志记录 checkout使用git checkout &lt;name&gt;也能撤销工作区内对文件的修改 从暂存区撤销修改我们将test.txt内容修改为 : 12this is a test txtfileadd a line to test recall 2 提交此次修改到暂存区 : 1226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git add . 文件差异1234567891011121314151617181920212226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff headdiff --git a/test.txt b/test.txtindex 2f59be1..7d6ebc9 100644--- a/test.txt+++ b/test.txt@@ -1 +1,2 @@ this is a test txtfile+add a line to test recall 226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff --cacheddiff --git a/test.txt b/test.txtindex 2f59be1..7d6ebc9 100644--- a/test.txt+++ b/test.txt@@ -1 +1,2 @@ this is a test txtfile+add a line to test recall 2 本地修改提交到暂存区后 工作区 暂存区无差异 工作区 版本库 与 暂存区 版本库差异相同 使用命令,将文件从暂存区撤销1$ git restore --staged test.txt 查看工作区状态12345678$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 工作区呈现我们对文件做出修改的状态: 提示我们将文件添加到暂存区,提示我们 提示我们使用restore撤销文件在工作区的修改 说明文件已经回到了我们对其做出修改且尚未提交到暂存区的状态 查看文件差异当我们把暂存区文件撤销回到工作区, 则工作区 暂存区差异与 工作区 版本库差异相同, 暂存区 版本库无差异 1234567891011121314151617181920212226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diffdiff --git a/test.txt b/test.txtindex 2f59be1..7d6ebc9 100644--- a/test.txt+++ b/test.txt@@ -1 +1,2 @@ this is a test txtfile+add a line to test recall 226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff headdiff --git a/test.txt b/test.txtindex 2f59be1..7d6ebc9 100644--- a/test.txt+++ b/test.txt@@ -1 +1,2 @@ this is a test txtfile+add a line to test recall 226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff --cached 查看文件内容12this is a test textadd a new line2 说明,将文件从暂存区撤回工作区,不会撤销此前我们的修改 从暂存区撤销后, 再撤销此前工作区的修改当我们从暂存区撤回文件后, 还可再撤销其在工作区的上次修改 此时应使用工作区撤销修改命令git restore filename,如下: 1$ git restore test.txt 查看文件内容; 1this is a test text 从版本库撤销准备 我们上面将test.txt文件恢复到了 : 1this is a test txtfile 我们为其标定版本 : 1git tag v1.0 查看log 12345678$ git log --pretty=oneline --abbrev-commit8244163 (HEAD -&gt; master, tag: v1.0) commit to test recall from commitabfb3b5 commit this testfile to comiit hist3699296 aa1dd8abb aa543a126 aa7abf4b6 add a new line by vim 可见当前版本(最新一次commit)被标定为了v1.0, 后面紧跟着最新一次commit的info 此时的版本v1.0对应test.txt文件内容为this is a test txtfile 我们对其做出如下修改 : 12this is a test txtfileadd a line by v2.0 提交到版本库 : 123$ git add . &amp;&amp; git commit -m &quot;commit to release v2.0&quot;[master be390c4] commit to release v2.0 1 file changed, 1 insertion(+), 1 deletion(-) 此处我们使用&amp;&amp;符号连接多个命令 为此次commit标定版本v2.0 : 1226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git tag v2.0 查看当前版本信息 : 123456789$ git log --pretty=oneline --abbrev-commitbe390c4 (HEAD -&gt; master, tag: v2.0) commit to release v2.08244163 (tag: v1.0) commit to test recall from commitabfb3b5 commit this testfile to comiit hist3699296 aa1dd8abb aa543a126 aa7abf4b6 add a new line by vim 可见上次commit信息commit to release v2.0出现, 且此时版本库为v2.0 至此, 我们为修改前的文件标定了v1.0, 为修改后的文件标定了v2.0 查看工作区状态123$ git statusOn branch masternothing to commit, working tree clean 查看文件差异当我将文件提交到版本库后, 各区内文件皆无差异 : 12345678926676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff head26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff --cached test.txt 此时文件内容12this is a test txtfileadd a line by v2.0 版本回退版本回退指的是将当前版本回退到之前的版本 使用commit id 或 tag进行版本回退基本命令为git reset --hard &lt;id/tag&gt; : 1. 使用tag进行回退 : 12326676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git reset --hard v1.0HEAD is now at 8244163 commit to test recall from commit 此时的文件内容 1this is a test txtfile可见版本回退之后, 文件也回到了该版本 2. 使用commit id回退 : 我们从上面的log中复制七位数的commit id 7abf4b6: 12326676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git reset --hard 7abf4b6HEAD is now at 7abf4b6 add a new line by vim 此时文件内容 : 1this is a test line 这是文件创建时, 使用vim添加的测试行 因此, 在每次commit时详细写好info大有用处 版本回退之后的版本信息log12345678$ git log --pretty=oneline --abbrev-commit7abf4b6 (HEAD -&gt; master) add a new line by vim00e7919 add a test.txt to repo40442a5 AA85f2fbb ADD T2.TXTbd8bfc5 add a line id = 3d5fe445 add a line id = 2fb84050 add a line id = 1 可见, 当我们回退版本之后, 普通log命令无法展示回退之前的信息 reflog展示详细log信息123456789101112$ git reflog --pretty=oneline --abbrev-commit7abf4b6 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 7abf4b68244163 (tag: v1.0) HEAD@&#123;1&#125;: reset: moving to v1.0be390c4 (tag: v2.0) HEAD@&#123;2&#125;: reset: moving to v2.0be390c4 (tag: v2.0) HEAD@&#123;3&#125;: commit: commit to release v2.08244163 (tag: v1.0) HEAD@&#123;4&#125;: reset: moving to 8244163199f71f HEAD@&#123;5&#125;: reset: moving to v1.08244163 (tag: v1.0) HEAD@&#123;6&#125;: commit: commit to test recall from commitabfb3b5 HEAD@&#123;7&#125;: commit: commit this testfile to comiit hist3699296 HEAD@&#123;8&#125;: commit: aa1dd8abb HEAD@&#123;9&#125;: commit: aa543a126 HEAD@&#123;10&#125;: commit: aa 我们使用reflog可以打印出历史版本中最远的版本记录 使用HEAD进行回退为方便演示, 我们将当前版本用tag回到v2.0时代 : 12345678926676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git reset --hard v2.0HEAD is now at be390c4 commit to release v2.026676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git log --pretty=oneline --abbrev-commitbe390c4 (HEAD -&gt; master, tag: v2.0) commit to release v2.08244163 (tag: v1.0) commit to test recall from commitabfb3b5 commit this testfile to comiit hist 此时的文件内容为 : 12this is a test txtfileadd a line by v2.0 git中HEAD指针指向当前版本(最新的commit id) HEAD^代表当前版本的上一个版本, HEAD^类推 我们使用HEAD来回退到v2.0的上一个版本(及v1.0) : 123456726676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git reset --hard HEAD^HEAD is now at 8244163 commit to test recall from commit26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git log --pretty=oneline --abbrev-commit8244163 (HEAD -&gt; master, tag: v1.0) commit to test recall from commit 可见当前版本回退到了v1.0 文件内容 : 1this is a test txtfile 文件也会回退到了v1.0","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-04-标签","slug":"git/git-04-标签","date":"2021-07-13T01:53:22.000Z","updated":"2021-07-17T02:19:42.940Z","comments":true,"path":"2021/07/13/git/git-04-标签/","link":"","permalink":"http://example.com/2021/07/13/git/git-04-%E6%A0%87%E7%AD%BE/","excerpt":"我们每次提交commit都会生成对应的commit id方便我们进行回溯 ，同样我们也可以手动为每个版本标定标签","text":"我们每次提交commit都会生成对应的commit id方便我们进行回溯 ，同样我们也可以手动为每个版本标定标签 git tag &lt;name&gt; - 创建标签git tag的基本语法为 ： 1git tag &lt;name&gt; 此处我们假定对master进行版本标记 ， 进入master分支 ： 12326676@DESKTOP-JCSGJPO MINGW64 /a/git/gitlearn (master)$ git checkout masterSwitched to branch &#x27;master&#x27; 使用命令进行版本标记 ： 1226676@DESKTOP-JCSGJPO MINGW64 /a/git/gitlearn (master)$ git tag v1.0 git tag - 查看标签git tag - 查看所有标签记录使用git tag查看当前分支标签记录 : 123$ git tagv1.0v2.0 但是此记录不是按照添加时间记录, 而是按照字母排序 git show &lt;tagname&gt; - 查看详细信息使用git show &lt;tagname&gt;查看各标签详细信息 : 1234567891011121314151617$ git show v1.0commit 199f71f3a9a825671b44a0790b619c531902a271 (tag: v1.0)Author: MarkLilyC &lt;2667602812@qq.com&gt;Date: Mon Jul 12 14:30:56 2021 +0800 AAdiff --git a/test.txt b/test.txtindex 1b63dd4..136aecc 100644--- a/test.txt+++ b/test.txt@@ -1,3 +1,5 @@ public line... -------------- add in A+--------------+add in B 追加标签每次git tag &lt;name&gt;都是默认添加在最新的commit的版本 当我们某次commit后忘记添加标签,可以向该版本追加标签 我们先随意进行几次提交 git log - 查看日志1234567891011121314151617181920$ git log --pretty=oneline --abbrev-commit8244163 (HEAD -&gt; master, tag: v2.0) commit to test recall from commitabfb3b5 commit this testfile to comiit hist3699296 aa1dd8abb aa543a126 aa7abf4b6 add a new line by vim00e7919 add a test.txt to repo40442a5 AA85f2fbb ADD T2.TXTbd8bfc5 add a line id = 3d5fe445 add a line id = 2fb84050 add a line id = 12e7ebbb add t.txt to the repo440e71c remove a file1e71bf1 rename8377709 rename8b0aa8b aa199f71f (tag: v1.0) AA0bbb931 aa 追加标签使用git tag &lt;name&gt; commit_id 对指定commit进行标签 : 1226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git tag v1.5 1dd8abb 1234$ git tagv1.0v1.5v2.0 可见新标签已被添加 删除标签使用git tag -d &lt;name&gt;删除指定标签 : 1234567826676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git tag -d v1.5Deleted tag &#x27;v1.5&#x27; (was 1dd8abb)26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git tagv1.0v2.0 可见v1.5被成功删除","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-03-分区及工作流程","slug":"git/git-03-分区及工作流程","date":"2021-07-13T00:53:22.000Z","updated":"2021-07-17T02:08:36.385Z","comments":true,"path":"2021/07/13/git/git-03-分区及工作流程/","link":"","permalink":"http://example.com/2021/07/13/git/git-03-%E5%88%86%E5%8C%BA%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/","excerpt":"git本地数据管理存在三个分区 : 工作区 暂存区 版本库","text":"git本地数据管理存在三个分区 : 工作区 暂存区 版本库 git 分区分区简介git的本地数据管理有以下三个分区 : 工作区-working directory : 可理解为本地文件夹以及对文件夹内部文件的操作, 我们在win10系统内日常对文件的新建 编辑 删除等操作都属于在工作区内的修改 暂存区-stage : 数据暂时存放的地方, 我们在工作区对文件做出修改后, 文件的修改信息一般需要提交存储到暂存区 版本库-commit History : 我们将暂存区内文件的修改信息提交后, 文件的最终修改版本存放的位置成为版本库 数据传递三个分区之间的数据传递 : 1. 在工作区对文件进行修改(本地文件) ↓ git add &lt;name&gt;-将工作区修改提交到暂存区 2. 文件被暂存到暂存区 ↓ git git commit &lt;name&gt;-将暂存区数据到版本库 3. 修改后的文件被存放到版本库 基本命令 git status-查看工作区状态 git add &lt;name&gt;-将工作区修改提交到暂存区 git commit &lt;name&gt;-将暂存区数据到版本库 git diff &lt;name&gt;-查看工作区与暂存区差异 git diff head &lt;name&gt;-查看工作区与版本库差异 git diff head --cached &lt;name&gt;-查看暂存区与版本库差异 working directory - 工作区 我们可以把工作区理解为本地文件夹 当我们直接在文件夹内对文件进行修改(新建 删除 编辑等操作) 或是在git bash内进行对文件修改 都属于工作区内的工作 为方便演示, 我们利用git bash进入上一节建立的/a/Git/gitlearn (master)中 ，同时也在windows文件夹内进行观察 ls12326676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ lstest.txt 当前位置仅存在我们上一节创建的示例test.txt git status123$ git statusOn branch masternothing to commit, working tree clean git提示 ： On branch master-表明当前工作区处于分支master (稍后将详细介绍) nothing to commit, working tree clean-表明当前工作区并未有任何对文件的修改 (因为上一节我们创建test.txt后已经进行了相关add与commit处理) 此时我们的工作区处于clean状态, 代表着无事发生 接下来, 我们对工作区进行相关演示 工作区内修改我们先利用vim test.txt进入该文件, 检查文本内容 : 1vim test.txt 可见文本为空(因为我们创建时, 并未做出任何修改), 如下 : 123456789101112131415161718192021222324~~~~~~~~~~~~~~~~~~~~~test.txt [unix] (13:06 13/07/2021) 1,23 All&quot;test.txt&quot; [unix] 0L, 0B 利用vim编辑器, 我们对test.txt文件做出以下修改 : 123456789101112131415161718192021222324this is a test txtfile~~~~~~~~~~~~~~~~~~~~~test.txt [unix] (13:06 13/07/2021) 1,23 All-- INSERT -- 此处的文件编辑也可使用记事本 status 更新保存退出后, 使用git status查看工作区状态 : 12345678$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git提示 ： On branch master-处于master分支 Changes not staged for commit-存在一些尚未提交到暂存区以待进一步提交commit的修改 : use &quot;git add &lt;file&gt;...&quot;-使用git add将修改提交到暂存区以待进一步commit use &quot;git restore &lt;file&gt;...&quot;-使用git restore撤销在工作区内的修改 modified: test.txt - 表明我们对test.txt被我们modified(修改) 至此, 我们可以看出: git能够检测到对仓库内的本地文件进行修改 此时 ，我们不对文件进行任何提交 ，仅仅将其保留在本地而此时, 暂存区以及版本库中存在的test.txt是我们在初始化仓库时提交的空文件接下来, 我们详细观察各区内文件的差异 各区内文件差异git diff - 工作区与暂存区123456789$ git diffwarning: LF will be replaced by CRLF in test.txt.The file will have its original line endings in your working directorydiff --git a/test.txt b/test.txtindex e69de29..2f59be1 100644--- a/test.txt+++ b/test.txt@@ -0,0 +1 @@+this is a test txtfile git提示 ： warning-提示我们git会将LF 换行符号转换为CRLF ，这并不影响 diff --git a/test.txt b/test.txt-查看test.txt的文件差异 我们关注最后一行 : +this is a test txtfile-表明我们添加了一行 由于我们并未将本地的修改提交到暂存区 ，因此暂存区内的test.txt依然是空文件 ，因此在对比两者文件差异时 ，自然会显示我们在工作区内文件新增一行 git diff head - 工作区与版本库123456789$ git diff headwarning: LF will be replaced by CRLF in test.txt.The file will have its original line endings in your working directorydiff --git a/test.txt b/test.txtindex e69de29..2f59be1 100644--- a/test.txt+++ b/test.txt@@ -0,0 +1 @@+this is a test txtfile 由于版本库和暂存区内的test.txt都是空文件 ，因此对比工作区与暂存区的差异与工作区与版本库的差异 ，二者几乎一致 3. git diff -cached 1226676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff --cached test.txt 版本库和暂存区都是空文件 ，自然不会有任何差异 查看本地文件我们暂时不管这些修改, 用记事本打开test.txt, 可以发现我们在vim内做出的修改呈现在了记事本 其他修改(如 新建文件 删除文件与此类似, 只是提示信息不同) git add - 工作区→暂存区git add &lt;name&gt;我们使用git add &lt;name&gt;将上面做出的修改提交到暂存库 提交前, 查看工作区状态, 提示我们有未提交修改, 如下 : 12345678$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 提交 ： 123$ git add test.txtwarning: LF will be replaced by CRLF in test.txt.The file will have its original line endings in your working directory 当我们有大量文件需要提交时, 可使用.代替文件名. 但应注意的是add与 .中间有空格 warning信息指git将回车换行转为CRLF, 可忽略 status更新12345$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: test.txt git提示中 : use &quot;git add &lt;file&gt;...&quot;消失, 表明我们已经将文件修改信息提交到了暂存区stage use &quot;git restore --staged &lt;file&gt;...&quot;-使用git restore --staged撤销此次提交 使用git add后, git提示事项中关于使用git add的提示消失 ，这表明我们成功使用了该命令将文件提交到了暂存区 暂存区查看文件差异分析 ：由于我们已经将文件提交到了暂存区 ，因此暂存区内文件与工作区一致 ，暂存区文件与版本库不一致 ： git diff12326676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff 如我们分析 ：工作区与暂存区无差异 2. git diff head 1234567$ git diff headdiff --git a/test.txt b/test.txtindex e69de29..2f59be1 100644--- a/test.txt+++ b/test.txt@@ -0,0 +1 @@+this is a test txtfile 工作区与版本库存在差异 3. git diff --cached 1234567$ git diff --cached test.txtdiff --git a/test.txt b/test.txtindex e69de29..2f59be1 100644--- a/test.txt+++ b/test.txt@@ -0,0 +1 @@+this is a test txtfile 暂存区与版本库存在差异 git commit - 暂存区→版本库commit 语法规则1git commit &lt;name&gt; -m &quot;info&quot; &lt;name&gt;-文件夹名, 为可选项 -m &quot;info&quot;-commit信息为必填, 在info处填入commit信息 使用commit12345$ git commit test.txt -m &quot;commit this testfile to comiit hist&quot;warning: LF will be replaced by CRLF in test.txt.The file will have its original line endings in your working directory[master abfb3b5] commit this testfile to comiit hist 1 file changed, 1 insertion(+) status更新1234$ git statusOn branch masternothing to commit, working tree clean git提示中clean, 表明此时工作区修改信息已经完全提交 版本库查看文件差异分析 ： 由于我们已经将文件提交到了版本库, 故工作区 暂存区差异 工作区 版本库差异 与 暂存区 版本库差异皆无差异 ： 1234567826676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff head26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ git diff --cached test.txt 修改提交当我们在将文件提交到仓库后又发现了其他微小错误,我们大可以在本地修改源文件后再次进行提交 但是也可以重写最近一次的提交,新的提交会覆盖掉错误的版本 语法为：git commit --amend&quot;commit information commit后的amend标志告诉git此次提交将会覆盖掉上次提交的内容,上次提交也不会在日志信息汇中出现 永远不要修改非最新提交，因为其他项目团队成员或其他分支有可能是基于该提交的版本。在修改提交之后，他们的版本将会失去了参考，版本控制很难从中恢复。","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-02-初始化本地仓库","slug":"git/git-02-初始化本地仓库","date":"2021-07-12T15:18:09.000Z","updated":"2021-07-16T15:44:56.164Z","comments":true,"path":"2021/07/12/git/git-02-初始化本地仓库/","link":"","permalink":"http://example.com/2021/07/12/git/git-02-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/","excerpt":"创建一个本地文件夹用以初始化本地仓库， 进行本地数据的管理","text":"创建一个本地文件夹用以初始化本地仓库， 进行本地数据的管理 在c盘创建一个Git文件夹,但此文件夹不是必要的在Git文件夹内创建一个用于学习git的文件夹gitlearn git init - 初始化仓库使用命令git init初始化仓库 1$ git init 随后便可以看见初始化成功的确认信息 12$ git initInitialized empty Git repository in A:/Git/gitlearn/.git/ 创建好第一个仓库后, 我们简单进行一些本地的数据管理演示 git status - 工作区状态status - 工作区状态我们在本地对文件进行修改后, git会检测到这些修改, 并提供相应的后续处理建议 以上操作记录即操作建议, 构成了工作区状态–status git status - 查看状态使用 git status 查看当前仓库信息 123456$ git statusOn branch masterNo commits yetnothing to commit (create/copy files and use &quot;git add&quot; to track) 可见此时仓库是空的,当前branch为master, 没有任何commit status - 更新新建文件我们尝试向仓库添加一个文本文件text.txt ： 使用 touch filename创建一个文件 使用 ls查看当前路径下的所有文件12345626676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ touch test.txt26676@DESKTOP-JCSGJPO MINGW64 /a/Git/gitlearn (master)$ lstest.txt 此处, 我们也可在文件夹内\"新建文件夹\" 查看新状态我们再次使用git status查看信息,可得 ： 1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) text1.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 显示我们新建了一个text1.txt文件,但是该文件未在git的追踪目录内 如果我们不添加和提交此文件,git便不会跟踪此文件 git add - 提交暂存区对于我们新建的文件test.txt, 我们想让git追踪其版本更迭, 此时我们应如上面git建议所 ：使用git add命令将其提交到暂存区 git add - 提交暂存区使用git add &lt;name&gt;命令将该文件添加到staging区域(即暂存区) ， 可得 ： 123$ git add text1.txtwarning: LF will be replaced by CRLF in text1.txt.The file will have its original line endings in your working directory 报错提示:The file will have its original line endings in your working directory 是因为git默认将文本中的回车换行统一为CRLF,不影响文本的实际使用 git status - 查看状态12345678$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: text1.txt 此时的提示信息更新为 ：git rm --cached &lt;file&gt;... ，提示我们使用rm来将文件从暂存区撤回git status - 工作区状态 git commit - 提交版本库使用git commit -m &quot;info&quot;将暂存区的文件提交到仓库中 ： 1234$ git commit -m &quot;the first commit. add text1.txt to the repository&quot;[master (root-commit) 21dced3] the first commit. add text1.txt to the repository 1 file changed, 1 insertion(+) create mode 100644 text1.txt -m后的信息为此次commit的信息 此时再次检查工作区的状态,可以看见干净的工作树 123$ git statusOn branch masternothing to commit, working tree clean git log - 日志信息使用git log获得历史提交记录 ： 123456$ git logcommit 21dced3ee6053a17e148ef75cd2d35863155f4a9 (HEAD -&gt; master)Author: MarkLilyC &lt;2667602812@qq.com&gt;Date: Sun Jul 11 16:50:18 2021 +0800 the first commit. add text1.txt to the repository 可见我们设置的提交信息被打印了出来 简化日志信息使用命令git log --pretty=onelin --abbrev-commit 12345678910111213141516171819202122232425$ git log --pretty=oneline --abbrev-commit8244163 (HEAD -&gt; master, tag: v2.0) commit to test recall from commitabfb3b5 commit this testfile to comiit hist3699296 aa1dd8abb aa543a126 aa7abf4b6 add a new line by vim00e7919 add a test.txt to repo40442a5 AA85f2fbb ADD T2.TXTbd8bfc5 add a line id = 3d5fe445 add a line id = 2fb84050 add a line id = 12e7ebbb add t.txt to the repo440e71c remove a file1e71bf1 rename8377709 rename8b0aa8b aa199f71f (tag: v1.0) AA0bbb931 aad219e28 aa08926e9 aaa638d98 aa9ee99cc aa 按下q退出 以上便是使用git init进行初始化的步骤, 以及一些简单的命令操作","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git-01-基本命令","slug":"git-01-基本命令","date":"2021-07-12T14:18:09.000Z","updated":"2021-07-17T01:30:26.822Z","comments":true,"path":"2021/07/12/git-01-基本命令/","link":"","permalink":"http://example.com/2021/07/12/git-01-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"windows系统进入git bash 后有大量的命令来解放鼠标操作 以下将介绍部分常用命令","text":"windows系统进入git bash 后有大量的命令来解放鼠标操作 以下将介绍部分常用命令 我们在随意位置打开 git bash pwd–查看当前位置使用 pwd 查看当前窗口处在位置 : 12326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ pwd/a/testfolder git 显示我当前的位置为 `/a/testfolder 即表明我当前处于 a 盘内 testfolder 文件夹内 我们也可以直观通过26676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder最后的文件夹位置查看 以下示例, 我们皆通过此行信息判定当前位置, 不再刻意使用pwd ls–查看文件(夹)使用 ls 查看当前位置所有的文件(夹) : 12326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ lsfolder1/ folder2/ git-分支合并.md git-工作流程.md git-文件操作.md 可见当前 /a/testfolder 文件夹内有两个文件夹 folder1/ 与 folder2 , 以及三个文件 git-分支合并.md 等 cd–进入文件夹单次进入使用 cd &lt;foldernam&gt; 进入目标文件夹 1234526676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ cd folder126676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder1$ 一般为确认当前位置存在哪些文件夹, 我们先使用 ls 查看当前位置存在的文件夹 在git bash内的复制粘贴为 crtl + insert 与 shift + insert 在 ls 结果中复制粘贴想使用的路径, 再进行后续操作 多次进入我们也可以直接在 cd 后使用我们想要去的最终路径 我们随意复制一个其他位置的路径, 如 : /e/pics/beatles 1234526676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder1$ cd /e/pics/beatles26676@DESKTOP-KEJKGL7 MINGW64 /e/pics/beatles$ 可以发现 cd 命令可以直接定位到目标路径, 不论该路径是否与我们当前位置有从属关系 cd ../退出文件夹使用cd ../退出当前文件夹, 返回上一级1234526676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder1$ cd ../26676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ 如上代码, 我们使用cd ../ 从 /a/testfolder/folder1 回退到了 /a/testfolder 组合使用cd ../回退多重文件夹为方便演示, 我们再次进入 /a/testfolder/folder1 : 1234526676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ cd folder126676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder1$ 对于前面使用过的代码, 比如此处的 `cd folder1 , 我们可以使用键盘 ↑ ↓ 来浏览我们使用过的命令, 再回车进行使用 对于不小心输入错误的命令, 我们可以使用 crtl + c 来撤销此次命令, 开始下一次的命令输入 12326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ cd folder1\\&gt; ^C 如上, 在输入 folder1 后不小心输入\\ 并按下了回车, 此时我们使用 crtl + c 便失效了此次命令输入, 直接进行下次输入 接下来我们正式使用多个 ../ 组合完成多级文件夹的回退 12345626676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder1$ cd ../../../../26676@DESKTOP-KEJKGL7 MINGW64 /$ pwd/ 如上, 我们使用四个 ../ 组合完成了四次的回退, 最终回到了不属于任何特定盘的位置 此时使用 pwd , git 告诉我们此时处于 / 这么一个位置, 我们可以把这个位置想象成所有文件的终根目录,从这里我们可以直接进入任何盘 mkdir创建文件夹为了方便演示, 我们回到 /a/testfolder 文件夹下 查看当前位置的文件(夹) : 12326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ lsfolder1/ folder2/ git-分支合并.md git-工作流程.md git-文件操作.md 我们想要创建一个 folder3 , 则使用 mkdir &lt;foldername&gt; : 1226676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ mkdir folder3 查看当前文件: 12326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ lsfolder1/ folder2/ folder3/ git-分支合并.md git-工作流程.md git-文件操作.md 可见 folder3 被成功创建 touch创建文件我们 cd folder3 进入刚才创建的 folder3 , 并查看当前文件夹内有哪些文件(夹) : 12345626676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder$ cd folder326676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ ls 可见当前文件夹内无任何文件(夹) 我们使用 touch &lt;filename&gt; 创建一个文件 : 12345626676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ touch test.txt26676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ lstest.txt 可见 test.txt 被成功创建 vim编辑器对文件进行简单编辑我们可以使用 vim 编辑器, 对刚才建立的 test.txt 文件进行简单编辑 : 使用 vim &lt;filename&gt; 命令来使用 vim 打开目标文件 : 1226676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ vim test.txt 回车后, 出现如下内容 : 123456789101112131415161718192021222324~~~~~~~~~~~~~~~~~~~~~test.txt [unix] (20:46 12/07/2021) 0,0-1 All&quot;test.txt&quot; 0L, 0B 每行前的 ~ 表明这是独立一行, 第一行无此符号 倒数第二行显示了一些此文件的基本信息, 如创建时间 尾行显示了此文件名 行数 大小 我们按下键盘 insert 键进入 insert 模式(即编辑模式), 此时最后一行变为 :-- INSERT -- 也只有在 insert 模式下我们才能做出修改 我们可以在光标闪烁处键入内容 : 1this is a test line vim 的退出 : 输入完毕后, 我们按下(或按住) esc 键, 此时屏幕进入闪烁状态, 且尾行的 insert 消失, 表明我们退出了编辑模式 此时我们输入一个 : , 即同时按下 shift + ; 键, 此时可以观察到尾行出现了我们刚才输入的 : , 且窗口停止闪烁 (此时若你是一直按着 esc , 那么我们可以松开 esc 键了) 输入 wq , 尾行变成了 :wq 最后按下回车键, 完成对文件的保存退出 我们完成测试编辑后, 使用 vim 或者记事本等编辑器打开该文件, 可见刚才的修改生效 : 123456789101112131415161718192021222324this is a test line~~~~~~~~~~~~~~~~~~~~~test.txt [unix] (20:58 12/07/2021) 1,18 All&quot;test.txt&quot; [unix] 1L, 21B vim 尾行显示了修改后的文件大小 rm删除文件使用 vim &lt;filename&gt; 删除文件 : 12345626676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ rm test.txt26676@DESKTOP-KEJKGL7 MINGW64 /a/testfolder/folder3$ ls 可见 test.txt 被成功删除 此外还有很多与具体事务相关的命令, 我们后续详细介绍","categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"python--函数","slug":"Python/basic/函数","date":"2021-07-10T04:21:57.000Z","updated":"2021-07-10T14:36:36.783Z","comments":true,"path":"2021/07/10/Python/basic/函数/","link":"","permalink":"http://example.com/2021/07/10/Python/basic/%E5%87%BD%E6%95%B0/","excerpt":"函数函数– 函数参数 参数类型","text":"函数函数– 函数参数 参数类型 默认参数 定义函数时设置默认值,则调用函数时不需要指定参数值12345&gt;&gt;&gt; def func(a = 1, b = 4):... return a * b...&gt;&gt;&gt; print(func())4 定义函数时设置默认值,调用函数指定他值,则他值覆盖默认值1234567&gt;&gt;&gt; def func(a = 1, b = 4):... return a * b...&gt;&gt;&gt; print(func())4&gt;&gt;&gt; print(func(2, 5))10 关键字参数(参数关键字) 调用函数传入参数时,若不指定各传入值对应参数名,则传入值会按照默认顺序(函数定义式中的参数顺序)进行参数赋值12345&gt;&gt;&gt; def func2(a, b, c, d):... return(a * 1000 + b * 100 + c * 10 + d)...&gt;&gt;&gt; print(func2(1,2,3,4))1234 调用函数传入参数时,指定参数关键字则不用在意参数传入顺序1234567&gt;&gt;&gt; def func2(a, b, c, d):... return(a * 1000 + b * 100 + c * 10 + d)...&gt;&gt;&gt; print(func2(1,2,3,4))1234&gt;&gt;&gt; print(func2(d=4, a=1, c=3, b=2))1234 任意参数1. 在任意参数前添加*标定此参数为任意参数 它将非关键字的参数作为元组传入函数内部1234567&gt;&gt;&gt; def func2(a, b, c, d):... return(a * 1000 + b * 100 + c * 10 + d)...&gt;&gt;&gt; print(func2(1,2,3,4))1234&gt;&gt;&gt; print(func2(d=4, a=1, c=3, b=2))1234 2. **kwargs 用以传递任意关键字参数(kew = ars) 将带传入参数及其关键字以&#39;&#39;键值对&#39;&#39;形式传入 传入参数及其关键字被转换为dict传入函数内部,通过关键字定位参数值123456789&gt;&gt;&gt; def func4(**kwargs):... print(kwargs.__class__)... for i in kwargs:... print(&#x27;this is &#x27; + str(i) + &#x27; and its arg = &#x27; +str(kwargs[i]))...&gt;&gt;&gt; func4(name = &#x27;markilily&#x27;,age = 120)&lt;class &#x27;dict&#x27;&gt;this is name and its arg = markililythis is age and its arg = 120","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--元组","slug":"Python/basic/元组","date":"2021-07-07T07:55:24.000Z","updated":"2021-07-10T14:34:58.036Z","comments":true,"path":"2021/07/07/Python/basic/元组/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E5%85%83%E7%BB%84/","excerpt":"列表与元组 当元素类型不一时使用元组,当类型一样则使用列表 [1] 元组遍历更快 使用元组元素(不可变)可作为字典的键值,而列表不可 元组保证了数据的安全","text":"列表与元组 当元素类型不一时使用元组,当类型一样则使用列表 [1] 元组遍历更快 使用元组元素(不可变)可作为字典的键值,而列表不可 元组保证了数据的安全 1 列表略 2 元组-tuple元组类似于列表,但区别在于元组中的元素是不可变的 2.1 创建一个元组1. 使用()创建一个元组,使用,间隔元素2. 类似于列表,元组中的元素可以是任何数据类型 123&gt;&gt;&gt; tuple1 = (&#x27;aa&#x27;, 1, [1,2,3])&gt;&gt;&gt; print(tuple1, tuple1.__class__)(&#x27;aa&#x27;, 1, [1, 2, 3]) &lt;class &#x27;tuple&#x27;&gt; 因为元组不能改变,所以创建伊始就应该指定正确的元素 3. 创建元组时只指明一个元素(dtype A),则该元组(你意图创建的)会被视为A的对象 123456789101112# case1&gt;&gt;&gt; a = (&#x27;aa&#x27;)&gt;&gt;&gt; print(a.__class__)&lt;class &#x27;str&#x27;&gt;# case2&gt;&gt;&gt; b = ([1,2,3])&gt;&gt;&gt; print(b.__class__)&lt;class &#x27;list&#x27;&gt;# case3&gt;&gt;&gt; c = (1)&gt;&gt;&gt; print(c.__class__)&lt;class &#x27;int&#x27;&gt; case1-3中意图创建元组a b c,但创建时指指定了一个内部元素param(dtype A),因此该元组被视为A类的一个对象 2.2 访问元组元素2.2.1 索引-index[index:int]使用索引操作符来访问元组中的元素1. 正索引 : 0-len(tuple)-1 123&gt;&gt;&gt; tuple1 = (&#x27;aa&#x27;, 1, [1,2,3])&gt;&gt;&gt; print(tuple1[2])[1, 2, 3] 2. 负索引 2.2.2 切片:使用切片操作符 123&gt;&gt;&gt; tuple1 = (&#x27;aa&#x27;, 1, [1,2,3])&gt;&gt;&gt; print(tuple1[1:])(1, [1, 2, 3]) 方法1. enumerate(): 将元组内所有对象及其索引枚举,以元组的形式返回 12&gt;&gt;&gt; print(enumerate(tuple1).__class__)&lt;class &#x27;enumerate&#x27;&gt; 2. tuple(): 将序列（元组，字符串，字典）转换为元组 1234&gt;&gt;&gt; list1 = [1,2,&#x27;aa&#x27;,(1,2,3)]&gt;&gt;&gt; tp1 = tuple(list1)&gt;&gt;&gt; print(list1.__class__, tp1.__class__)&lt;class &#x27;list&#x27;&gt; &lt;class &#x27;tuple&#x27;&gt; 3. sorted: 返回一个排序元组 123&gt;&gt;&gt; tuplle1 = (2,2,3,0)&gt;&gt;&gt; print(sorted(tuplle1))[0, 2, 2, 3] 参考参考资料1 ↩","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--命名空间","slug":"Python/basic/命名空间","date":"2021-07-07T07:43:24.000Z","updated":"2021-07-10T14:36:48.586Z","comments":true,"path":"2021/07/07/Python/basic/命名空间/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","excerpt":"命名空间及作用域1.命名空间1.1 命名空间（Namespace）1. 是从名称到对象的映射，一般通过字典实现2. 类似于c++","text":"命名空间及作用域1.命名空间1.1 命名空间（Namespace）1. 是从名称到对象的映射，一般通过字典实现2. 类似于c++ 1using namespace std 1.2 命名空间主要为了避免对象名称冲突1. 各个命名空间之间相互独立2. 命名空间内部不能有同名称对象3. 各个命名空间之间可以有相同名称对象 123# 如计算机内部文件夹之间的关系： * 单个文件夹内部不能有同名称元素 * 不同文件夹之间可以同名称元素 1.3 python一般有三种命名空间：内置-built in 局部(本地)-local 全局-global1.3.1 局部1. 局部空间包含:函数中定义的名称,记录了函数的变量,包括函数的参数与局部变量 此局部指的是此作用域,及其内部包含的对象 名称 2. locals():返回当前位置的全部局部变量 当前位置指的是当前locals()函数被调用的位置 全局内使用locals():所有有实例的函数 方法 lambda函式以及实现了__call__的,都会返回true12&gt;&gt;&gt; print(locals())&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;len&#x27;: &lt;function len at 0x00000186888145E8&gt;&#125; 此时的局部空间等于全局空间 函数内部使用locals():返回此函数空间内的所有名称及对象123456&gt;&gt;&gt; def len(param):... in_param = 2... print(locals())...&gt;&gt;&gt; len(4)&#123;&#x27;param&#x27;: 4, &#x27;in_param&#x27;: 2&#125; 循环内使用locals(): 12345&gt;&gt;&gt; for i in [1,2]:... print(locals())...&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;i&#x27;: 1&#125;&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;i&#x27;: 2&#125; 证明for循环不算一个单独的作用域 1.3.2 全局1. 全局空间包含:模块中定义的名称,记录了模块的变量,包括函数 类 导入模块 可理解为此.py文件所代表的空间 2. globals():返回当前全局空间内的名称及对象 全局内使用globals():12&gt;&gt;&gt; print(globals())&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;i&#x27;: 2&#125; 全局命名空间里包括了整个模块内的命名名称，比如变量 x y 函数名,而且还包括了一些内置的变量命名，比如 __name__ __file__等等。 全局空间与全局使用局部空间相同:123456&gt;&gt;&gt; if locals() == globals():... print(&#x27;yes&#x27;)... else:... print(&#x27;no&#x27;)...yes 1.3.3 内置1. 内置空间包含:python语言的内置名称,如函数名abs char等1.4 各空间关系1. 命名空间使用顺序:局部-&gt;全局-&gt;内置 这样可以完成对全局 内置函数的’’改写’’:12345&gt;&gt;&gt; def len(param):... print(param)...&gt;&gt;&gt; len([1,2,3,4])[1, 2, 3, 4] python内置此方法的输出为元素长度:12&gt;&gt;&gt; print(len([1,2,3,4]))[1, 2, 3, 4] 当无法找到此名称的对象时,则抛出异常命名空间的生命周期命名空间的声明周期却决与该变量的作用域,对象执行完成,则该命名空间的生命周期结束2. 作用域2.1 作用域1. 作用域:访问某变量 对象的区域 每个对象都存在特定的作用域中 作用时段中 当前程序未执行到该作用域,则某些只存在于该作用域的对象则不能被访问 或者说,只有被赋值且未该赋值区域未完成其全部功能时,该对象才能被访问 简单来说就是:该对象在未赋值时,不能被访问;使用结束跳出该域后也不能访问 2.2 作用域分类2.2.1 L-local 局部作用域2.2.2 E-encloing scope 闭包函数作用域,嵌套函数(A(B(var c)))中var c所在作用域2.2.3 G=global2.2.4 B-built in1. 内置作用域的实现是通过builtin标准模块实现 但是此变量名本身并未放入内置作用域,需要导入模块才能使用2. builtin 12&gt;&gt;&gt; import builtins&gt;&gt;&gt; dir(builtins) 2.3 规则1. 当在函数中引用一个变量的时候，以上的作用域顺序也是 Python 搜索的一个顺序 L-&gt;E-G-B，首先尝试局部作用域，没找到的话，继续搜索闭包函数作用域，然后再是全局作用域和内置作用域。2. Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域 其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问(如1.3.1.2) 如:12345&gt;&gt;&gt; if True:... testStr = &#x27;this is a testline to test if this is a new region&#x27;...&gt;&gt;&gt; print(testStr)this is a testline to test if this is a new region","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--集合","slug":"Python/basic/集合","date":"2021-07-07T07:40:24.000Z","updated":"2021-07-10T14:36:39.371Z","comments":true,"path":"2021/07/07/Python/basic/集合/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E9%9B%86%E5%90%88/","excerpt":"集合-set集合的基本性质:1. 集合包含了不重复且无序的元素2. 集合是可变数据类型","text":"集合-set集合的基本性质:1. 集合包含了不重复且无序的元素2. 集合是可变数据类型 但是其内部元素必须是不可变数据类型,即元组可以作为其元素,但是列表 集合 字典不能作为其元素 1234&gt;&gt;&gt; c = &#123;1,2,3,[1,2]&#125;Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: &#x27;list&#x27; 1. 创建集合 使用&#123;&#125;创建集合,内部元素使用,分隔 使用python内置函数set()1234&gt;&gt;&gt; a = &#123;1,2,3,tuplle1&#125;&gt;&gt;&gt; b = set([1,3,&#x27;SS&#x27;,tuplle1])&gt;&gt;&gt; print(a.__class__, b.__class__)&lt;class &#x27;set&#x27;&gt; &lt;class &#x27;set&#x27;&gt; 2. 修改集合 不能通过索引 切片操作来访问其中的元素,因为集合是无序的2.1 添加元素1. add()方法添加单个元素2. update()方法添加多个元素12345678&gt;&gt;&gt; a = &#123;1,2,3,tuplle1&#125;&gt;&gt;&gt; a.add(&#x27;aa&#x27;)&gt;&gt;&gt; print(a)&gt;&gt;&gt; a = &#123;1,2,3&#125;&gt;&gt;&gt; a.update([2,4])&gt;&gt;&gt; print(a)&#123;1, 2, 3, 4&#125; 集合内不重复的性质会自动去掉update()参数中的重复元素 2.2 删除元素1. discard()2. remove()12345678910111213&gt;&gt;&gt; a.discard(2)&gt;&gt;&gt; print(a)&#123;1, 3, 4&#125;&gt;&gt;&gt; a.remove(1)&gt;&gt;&gt; print(a)&#123;3, 4&#125;&gt;&gt;&gt; a.discard(10)&gt;&gt;&gt; a.remove(11)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 11 二者差别在于,当被去除元素不存在时,discard不会报错,remove报错 3. pop():去掉任意一个元素 12&gt;&gt;&gt; a.pop()3 4. clear() 清空结合 1234567&gt;&gt;&gt; a.update([1,2,3,4,5,6,7,9])&gt;&gt;&gt; print(a)&#123;1, 2, 3, 4, 5, 6, 7, 9&#125;&gt;&gt;&gt; a.clear()&gt;&gt;&gt; print(a)set() 2.3 集合的逻辑操作1. &amp; / intersection – 交集 123456789&gt;&gt;&gt; x = &#123;1, 2, 3, 4, 5, 6&#125;&gt;&gt;&gt; y = &#123;7, 8, 9, 10, 11, 12&#125;&gt;&gt;&gt; print(x&amp;y)set()&gt;&gt;&gt; print(x.intersection(y))set()&gt;&gt;&gt; x.update([7,8,9])&gt;&gt;&gt; print(x.intersection(y))&#123;8, 9, 7&#125; 当二者无交集,则返回空set 2. - / difference – 差集:只在其一集合中出现 123456x = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;y = &#123;7, 8, 9, 10, 11, 12&#125;&gt;&gt;&gt; print(x-y)&#123;1, 2, 3, 4, 5, 6&#125;&gt;&gt;&gt; print(x.difference(y))&#123;1, 2, 3, 4, 5, 6&#125; 3. ^ / symmetric_difference – 对称差集:不同时出现在两个集合的元素 12&gt;&gt;&gt; print(x^y, x.symmetric_difference(y))&#123;1, 2, 3, 4, 5, 6, 10, 11, 12&#125; &#123;1, 2, 3, 4, 5, 6, 10, 11, 12&#125; 4. union() – 求并集 3 不可变集合 由于集合的元素可变,所以无法作为字典的键值 采用frozenset()可以创建不可变元素的不可变集合 123&gt;&gt;&gt; a = frozenset(&#123;1,2,3&#125;)&gt;&gt;&gt; print(a)frozenset(&#123;1, 2, 3&#125;)","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--类","slug":"Python/basic/类","date":"2021-07-07T07:33:24.000Z","updated":"2021-07-11T16:54:51.891Z","comments":true,"path":"2021/07/07/Python/basic/类/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E7%B1%BB/","excerpt":"类–CLASSpython中的类与对象类可以说是具有同类型属性（性质 方法 属性）的对象的属性集合 类中包含的就是该类对象共有的属性（性质 方法 属性）","text":"类–CLASSpython中的类与对象类可以说是具有同类型属性（性质 方法 属性）的对象的属性集合 类中包含的就是该类对象共有的属性（性质 方法 属性） 对象则是包含了类中具体属性（性质 方法 属性）的实体 对象则是具体指明 实现了类中各类属性的实体 新建一个类class关键字新建一个类: 123456789&gt;&gt;&gt; class stu:... name = &#x27;aa&#x27;... def display():... print(&#x27;im aa&#x27;)...&gt;&gt;&gt; print(stu.name)aa&gt;&gt;&gt; print(stu.display)&lt;function stu.display at 0x00000279CBA24798&gt; 新建一个类的实例对象12345&gt;&gt;&gt; cj = stu()&gt;&gt;&gt; print(cj.name)aa&gt;&gt;&gt; cj.display&lt;bound method stu.display of &lt;__main__.stu object at 0x00000279CBA36CC8&gt;&gt; 类属性除了自定义的属性 方法,python提供一系列的内置属性 __dict__: 包含命名空间的字典 __doc__: 类的说明文档 __name__：类的名称 __module__: 定义类的所在模块 __bases__: 包含基础类的元组12345678910111213&gt;&gt;&gt; class stu:... &#x27;this is test line&#x27;... name = &#x27;cj&#x27;... def dis():... print(&#x27;display&#x27;)...&gt;&gt;&gt; s = stu()&gt;&gt;&gt; print(s.__doc__)this is test line&gt;&gt;&gt; print(s.__dict__)&#123;&#125;&gt;&gt;&gt; print(s.__module__)__main__ 类构造方法__init__()方法用于对象被初始创建时调用,用于初始化生成类的具体属性 不同于java,python类的属性直接在init函数内声明,不需要额外声明12345678910&gt;&gt;&gt; class stu:... def __init__(self, init_name, init_age):... self.name = init_name... self.age = init_age... def introducing(self):... print(&quot;my name is &quot; + self.name + &#x27; and im &#x27; + str(self.age) + &#x27; old.&#x27;)...&gt;&gt;&gt; s = stu(&#x27;marklily&#x27;, 18)&gt;&gt;&gt; s.introducing()my name is marklily and im 18 old. 删除类的属性del用于删除对象的某个属性:12345&gt;&gt;&gt; s.__dict__&#123;&#x27;name&#x27;: &#x27;marklily&#x27;, &#x27;age&#x27;: 18&#125;&gt;&gt;&gt; del s.age&gt;&gt;&gt; s.__dict__&#123;&#x27;name&#x27;: &#x27;marklily&#x27;&#125; 继承继承中有子类与父类,甚至祖父类.子类继承父类中的所有属性 方法,并且可以添加新函数 属性 继承中的添加 子类继承父类中的所有方法,包括构造方法 12345678910111213141516171819# 创建父类class ParentClass: familyName = &#x27;c&#x27; familyLocation = &#x27;sc&#x27; def __init__(self, name, age): self.name = name self.age = age def introducing(self): print(&#x27;Name: &#x27; + self.name + &#x27;Age: &#x27; + str(self.age))# 创建一个父类对象 并检验相关属性parent = ParentClass(&#x27;markc&#x27;, 22)print(parent.familyName + parent.familyLocation)parent.introducing()# 创建子类 继承父类class ChildClass(ParentClass): passchild = ChildClass(&#x27;axlc&#x27;, 2)print(child.familyName + child.familyLocation)child.introducing() 1234cscName: markcAge: 22cscName: axlcAge: 2 子类添加新函数 新属性 1234567class ChildClass(ParentClass): newFamilyJob = &#x27;IT&#x27; def newJob(self): print(&#x27;new job is &#x27; + &#x27;IT&#x27;)child = ChildClass(&#x27;axlc&#x27;, 2)print(child.newFamilyJob)child.newJob() 12ITnew job is IT 继承中的覆写子类在继承父类方法时间,可对方法做出重写 1234567891011121314151617181920212223class ParentClass: familyName = &#x27;c&#x27; familyLocation = &#x27;sc&#x27; def __init__(self, name, age): self.name = name self.age = age def introducing(self): print(&#x27;Name: &#x27; + self.name + &#x27;Age: &#x27; + str(self.age))class ChildClass(ParentClass): newFamilyJob = &#x27;IT&#x27; def __init__(self, name, age, coupledNum): self.name = name self.age = age self.coupledNum = coupledNum def newJob(self): print(&#x27;new job is &#x27; + &#x27;IT&#x27;) def introducing(self): print(&#x27;Name: &#x27; + self.name + &#x27;Age: &#x27; + str(self.age) + &#x27;and i only got &#x27; + str(self.coupledNum))child = ChildClass(&#x27;axlc&#x27;, 2, 1)print(child.newFamilyJob)child.newJob()child.introducing() 12345cscName: markcAge: 22ITnew job is ITName: axlcAge: 2and i only got 1 子类中对构造函数做出了重写,新加入了coupledNum属性,对introducing方法也做出了重写 多重继承当一个子类有多个父类时,多个父类均被继承 12345678910111213141516171819202122232425&gt;&gt;&gt; class A:... def disA(self):... print(&#x27;A&#x27;)...&gt;&gt;&gt; class B:... def disB(self):... print(&#x27;B&#x27;)...&gt;&gt;&gt; class C:... def disC(self):... print(&#x27;C&#x27;)...&gt;&gt;&gt; class son(A,B,C):... def disSon(self):... print(&#x27;son&#x27;)...&gt;&gt;&gt; son = son()&gt;&gt;&gt; son.disA()A&gt;&gt;&gt; son.disB()B&gt;&gt;&gt; son.disC()C&gt;&gt;&gt; son.disSon()son 多级继承基因代代相传,孝景帝之子中山靖王之后刘玄德也可以用的 123456789101112131415161718&gt;&gt;&gt; class A:... def disA(self):... print(&#x27;A&#x27;)&gt;&gt;&gt; class D(A):... def disD(self):... print(&#x27;D&#x27;)...&gt;&gt;&gt; class E(D):... def disE(self):... print(&#x27;E&#x27;)...&gt;&gt;&gt; e = E()&gt;&gt;&gt; e.disA()A&gt;&gt;&gt; e.disD()D&gt;&gt;&gt; e.disE()E","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Numpy--NumpyNotes","slug":"numpy/NumpyNotes","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-11T16:56:29.098Z","comments":true,"path":"2021/07/07/numpy/NumpyNotes/","link":"","permalink":"http://example.com/2021/07/07/numpy/NumpyNotes/","excerpt":"Numpy1.ndarrayNumpy的数组类是ndarray，但其不同于array（只是一个以为数组）","text":"Numpy1.ndarrayNumpy的数组类是ndarray，但其不同于array（只是一个以为数组） ndarray.ndim:数组的dimension,Python中的rank nmarray.shape:数组的维数 ndarray.size:数组中所有元素的数量 ndarray.dtype:数组中所有元素的类型 ndarray.itemsize:数组中元素的大小,字节为单位 ndarray.data:存储array的缓冲12345678910111213def get_all_info(ndarr1): print(ndarr1, &#x27;basic info:&#x27;) print(&#x27;dimension:&#x27;, ndarr1.ndim) print(&#x27;shape:&#x27;, ndarr1.shape) print(&#x27;size:&#x27;, ndarr1.size) print(&#x27;dtype:&#x27;, ndarr1.dtype) print(&#x27;itemsize&#x27;, ndarr1.itemsize) print(&#x27;data:&#x27;, ndarr1.data)arr1 = np.array([1, 2])arr2 = np.array([(1,2,3), (4,5,6)])arr2 = np.array([(1,2,3), (4,5,6), (7,8,9)])get_all_info(arr1)get_all_info(arr2) this tures out:12345678910111213141516[1 2] basic info:dimension: 1shape: (2,)size: 2dtype: int32itemsize 4data: &lt;memory at 0x000001EEBB018348&gt;[[1 2 3] [4 5 6] [7 8 9]] basic info:dimension: 2shape: (3, 3)size: 9dtype: int32itemsize 4data: &lt;memory at 0x000001EEBB02F908&gt; TIPS: array.shape与np.shape()的区别 array.shape获取的是某个具体已声明的ndarray的属性,在其初始化时已经确定 np.shape()是np包中的一个方法,传入一个ndarray作为参数,获取其shape 123arr3 = np.array([(1,2,3), (4,5,6), (7,8,9)])print(&#x27;arr3.shape gets: &#x27;, arr3.shape)print(&#x27;np.shape(arr3) gets :&#x27;, np.shape(arr3)) this turns out: 12arr3.shape gets: (3, 3)np.shape(arr3) gets : (3, 3) 也可以在创建ndarray时指定数据类型(dtype): 1234arr3 = np.array([(1,2,3), (4,5,6), (7,8,9)])arr4 = np.array([(1,2,3), (4,5,6), (7,8,9)], dtype=np.uint8)print(&#x27;arr3`s dtype is&#x27;, arr3.dtype)print(&#x27;arr4`s dtype is&#x27;, arr4.dtype) it turns out: 12arr3s dtype is int32arr4s dtype is uint8 2.常见特定数组 zeros:数组中元素为0 ones:1 empty:类似与0,but not arange:在将一维数组按跨度分隔 linespace:将一维数组均分 random:随机 随机数方法:1234* random() 0-1内的随机实数* uniform(a, b) a-b内的随机浮点数* randint(a, b) a-b内的随机整数* 一些其他方法 1234567a = np.zeros((2, 3))b = np.ones((2, 3))c = np.empty((2, 4))d = np.arange(1, 2, 0.3)e = np.linspace(1, 2 ,7)f = np.random.random((2, 3))print(a,b,c,d,e,f) it turns out:1234567891011[[0. 0. 0.] [0. 0. 0.]][[1. 1. 1.] [1. 1. 1.]][[0.00000000e+000 0.00000000e+000 0.00000000e+000 0.00000000e+000] [0.00000000e+000 2.03555046e-321 1.42410974e-306 0.00000000e+000]][1. 1.3 1.6 1.9][1. 1.16666667 1.33333333 1.5 1.66666667 1.83333333 1. ][[0.56551478 0.58715817 0.51182441] [0.18129758 0.33167464 0.66718211]] TIPS: np.empty 创建一个没有任何具体值的ndarray数组，是创建数组最快的方法 不会给元素初始化值,运行速度快于ones,但具体使用需要用户手动赋值 形状与操作形状 reshape：用于基于现有数组和指定形状生成新数组，就是重塑行列1234a = np.arange(1, 10)print(&#x27;original a = \\n&#123;&#125;\\n&#x27;.format(a), &#x27;and shape = \\n&#123;&#125;\\n&#x27;.format(a.shape))a = a.reshape(3, -1)print(&#x27;a.reshape(3, -1) = \\n&#123;&#125;\\n&#x27;.format(a), &#x27;and shape = \\n&#123;&#125;\\n&#x27;.format(a.shape)) it turens out1234567891011original a = [1 2 3 4 5 6 7 8 9] and shape = (9,)a.reshape(3, -1) =[[1 2 3] [4 5 6] [7 8 9]] and shape =(3, 3) 其中参数2 = -1,即视情况而定,将其转换为3*3 reshape前后的元素个数一定保持一致才能进行转换 vstack：用于在垂直方向上堆叠多个数组(数组的维度必须匹配)123456a = np.arange(1, 3)print(&#x27;original a = \\n&#123;&#125;\\n&#x27;.format(a), &#x27;and shape = \\n&#123;&#125;\\n&#x27;.format(a.shape))b = np.arange(4, 6)print(&#x27;original b = \\n&#123;&#125;\\n&#x27;.format(b), &#x27;and shape = \\n&#123;&#125;\\n&#x27;.format(b.shape))c = np.vstack((a, b))print(&#x27;vstack ((a, b)) = c = \\n&#123;&#125;\\n&#x27;.format(c), &#x27;and shape = \\n&#123;&#125;\\n&#x27;.format(c.shape)) it turns out:12345678910111213original a = [1 2] and shape = (2,)original b =[4 5] and shape =(2,)vstack ((a, b)) = c =[[1 2] [4 5]] and shape =(2, 2) hstack：用于水平方向堆叠多个数组(数组的维度必须匹配) hsplit：用于水平分割数组 vsplit：用于垂直分割数组 index通过index访问数组中的数据 12a = np.array([(1,2,3),(4,5,6),(7,8,9)])print(a[1][2]) 16 可以通过创建一个包含目标index的数组来访问获取目标数组123a = np.arange(100, 200)a_index_five = np.arange(0, 100, 4)print(&#x27;a[a_index_five] = \\n&#123;&#125;\\n&#x27;.format(a[a_index_five])) it tures out:123a[a_index_five] = [100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196] 下标数组也可以是多维的,并将获得的数据转换为多维度数组(维度同下标数组)12345a = np.arange(100, 200)a_index_five = np.array([(1, 2), (10, 20)])print(&#x27;a_index_five = \\n&#123;&#125;\\n&#x27;.format(a_index_five), &#x27;shape= \\n&#123;&#125;\\n&#x27;.format(a_index_five.shape))a_select = a[a_index_five]print(&#x27;a[a_index_five] = \\n&#123;&#125;\\n&#x27;.format(a_select), &#x27;shape = \\n&#123;&#125;\\n&#x27;.format(a_select.shape)) it turns out:1234567891011a_index_five = [[ 1 2] [10 20]] shape= (2, 2) a[a_index_five] =[[101 102] [110 120]] shape =(2, 2) 二维数组的访问 一维访问123456a = np.arange(100, 200)a = a.reshape(10, -1)# 指定一个下标[i],则获取该行元素(第i个数组)print(a[0])# 指定两个连续的下标[i][j],则获取该行该个元素(i行j列)print(a[0][3]) it turns out12[100 101 102 103 104 105 106 107 108 109]103 二维访问需通过:指定范围1print(&#x27;a[2:4, 2:5 = \\n&#123;&#125;\\n&#x27;.format(a[2:4, 2:5])) turns out:12[[122 123 124][132 133 134]] 2:4, 2:5指第2 3行下的第 2 3 4列Tips:使用x,: 或 :,y 获取第x行所有 与 y列所有 1print(&#x27;a[2,:] = \\n&#123;&#125;\\n&#x27;.format(a[2,:])) turns out12a[2,:] = [120 121 122 123 124 125 126 127 128 129] 矩阵np中矩阵仍然是ndarray,只是以矩阵的方式操作 转置1234a = np.random.randint(0, 4, size=[4, 4]) print(&#x27;original a = \\n&#123;&#125;\\n&#x27;.format(a))print(&#x27;a.T = \\n&#123;&#125;\\n&#x27;.format(a.T))print(&#x27;a.transpose = \\n&#123;&#125;\\n&#x27;.format(a.transpose())) turns out: 123456789101112131415[0 2 1 2][3 0 1 3][2 0 0 3]]a.T =[[0 0 3 2][1 2 0 0][3 1 1 0][1 2 3 3]]a.transpose =[[0 0 3 2][1 2 0 0][3 1 1 0][1 2 3 3]] dot乘法 123456a = np.random.randint(0, 4, size=[4, 4]) b = np.uint(np.ones((4, 1)))c = np.dot(a, b)print(&#x27;a shape = \\n&#123;&#125;\\n&#x27;.format(a.shape),&#x27;\\n&#x27;, &#x27;b shape = \\n&#123;&#125;\\n&#x27;.format(b.shape))print(a.dot(b))print(&#x27;c shape = \\n&#123;&#125;\\n&#x27;.format(c.shape)) turns out: 123456789101112a shape = (4, 4)b shape =(4, 1)[[8][5][6][6]]c shape =(4, 1)","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"Numpy","slug":"Python/Numpy","permalink":"http://example.com/categories/Python/Numpy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://example.com/tags/Numpy/"}]},{"title":"Numpy100--Numpy100","slug":"numpy/numpy100","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:38:41.199Z","comments":true,"path":"2021/07/07/numpy/numpy100/","link":"","permalink":"http://example.com/2021/07/07/numpy/numpy100/","excerpt":"github上的开源项目2021.7.4 17：06","text":"github上的开源项目2021.7.4 17：06 创建一个长度为10的空向量12z = np.zeros(10)print(z) 找到数组的内存大小12z = np.zeros(10)print(z.size * z.itermsize) z.size获取到内部的元素个数z.itemsize获取到各个元素的大小 从命令行对得到相关函数的说明文档1print(np.info(np.add)) 创建一个长度为10,且除了第五个元素为1的空向量123z = np.zeros(10)z[4] = 1print(z) 创建值域10-49的向量1z = np.arange(10, 50) 反转一个向量1234z = np.arange(0, 5)print(z)z = z[::-1]print(z) b = [0 1 2 3 4]a = b[x : y]: 两索引各自计算,正值从左侧开始,负值从右侧开始 左侧索引元素在右侧索引元素左侧,则返回非空 某侧无索引则代表,从另一侧索引顺方向计数完 a为两侧索引之内交集元素返回的array 若两侧索引之内无元素,则a为空array a = b[4:2] : a = []a = b[-3:4] : a = []a = b[4:-2] : a = [] x&gt;0 y&gt;0 a = b[x:y]: a = x-y内元素返回array a = b[ :y]: a = 0-y内元素返回 a = b[x: ]: a = x-len(b)内元素返回 x &lt; y : a = [] x&lt;0 or y&lt;0 a = b[-4:-1]: a = b中-4号元素到-1号元素返回 a = b[-4:1]: a = [] a = b[-4:]: a = -4 - 0索引之间元素返回 a = b[:-4]: a = [] a = b[3:-4]: a = [] a = b[::a] 在b中没隔a取一个元素返回a 取值方向由a正负决定 创建一个3 * 3,值域:0-8的矩阵12z = np.arange(0,9).reshape(3,3)print(z) 找到数组中的0元素索引12z = np.array([0, 1, 0, 3, 4, 0])print(z.nonzero()) 创建一个3 * 3的单位矩阵12z = np.eye(3)print(z) 创建一个3 * 3的随机数据123from numpy import randomz = np.random.random((3, 3, 3))print(z) 创建一个10 * 10的随机数组,并获取最小与最大值123from numpy import randomz = np.random.random((10, 10))print(z.min(), z.max()) 创建一个长度为30的随机向量,并获取其平均值1234from numpy import randomz = np.random.random((30))zMean = z.mean()print(zMean) 创建一个二维数组,其边界值为1,其余值为0123z = np.ones((6, 6))z[1:-1, 1:-1] = 0print(z) 其原理是:用array[a:b,c:d] = x进行对二维数组赋值的方式 array[1:-1,1:-1] = x其原理类似a = b[1:-1]从行索引为从第一行到-1行(及倒是第二行),这样根据每个array的大小去调整参数 对于一个存在的数组,如何用0填充其边界123z = np.ones((6, 6))z = np.pad(z, pad_width=1, mode=&#x27;constant&#x27;, constant_values=0)print(z) 下列各式的运行结果 0 * np.nan –&gt; nan np.nan==np.nan –&gt; False np.inf &gt; np.nan –&gt; False np.nan - np.nan –&gt; nan 0.3 == 3 * 0.1 –&gt; False nan 不是数字,是不存在 inf infinite 创建一个5 * 5的矩阵,并设置1 2 3 4落在其对角线的下方12Z = np.diag(1+np.arange(4), k = -1)print(Z) np.diag(array_like, k) 返回此array第k位置对角线的矩阵 当只传入矩阵,则返回此矩阵的对角线元素","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"Numpy","slug":"Python/Numpy","permalink":"http://example.com/categories/Python/Numpy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://example.com/tags/Numpy/"}]},{"title":"python--map函数","slug":"Python/advance/map函数","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-11T16:55:03.976Z","comments":true,"path":"2021/07/07/Python/advance/map函数/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/map%E5%87%BD%E6%95%B0/","excerpt":"map函数 python内置函数 会根据给定函数,对指定序列做出映射","text":"map函数 python内置函数 会根据给定函数,对指定序列做出映射 mapmap(function, iterable...) iterable 作为映射中原数据的来源 function 用于对iterable中的元素进行转换 1234&gt;&gt; def squ(x):... return x * x...&gt;&gt;&gt; mapResult = map(squ, [1,2,3,4,5]) python 2. 返回列表 python 3. 返回迭代器 12345678910&gt;&gt;&gt; print(mapResult.__class__)&lt;class &#x27;map&#x27;&gt;&gt;&gt;&gt; for i in mapResult:... print(i)...1491625 可通过list(map())的显示转换来消除版本之间的差异 123456&gt;&gt;&gt; def squ(x):... return x * x...&gt;&gt;&gt; list1 = list(map(squ, [1,2,3,4,5]))&gt;&gt;&gt; print(list1)[1, 4, 9, 16, 25] lambda12&gt;&gt;&gt; print(list(map(lambda x : x * x, [1,2,3,4,5])))[1, 4, 9, 16, 25] 技巧map完成数据类型转换12&gt;&gt;&gt; print(list(map(str, [1,2,3,4,5])))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;] map元组转列表123&gt;&gt;&gt; list1 = list(map(int,(1,2,3)))&gt;&gt;&gt; print(list1)[1, 2, 3] 原理是:元组作为迭代器可作为map()函数参数传入,当元组内部元素数据类型与function转出数据类型一致时,再将map返回迭代器转为列表","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--装饰器","slug":"Python/advance/python装饰器","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:36:20.340Z","comments":true,"path":"2021/07/07/Python/advance/python装饰器/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/python%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"装饰器Python装饰器能够动态地改变函数 方法 类的功能,而不用子类重写或修改函数源代码的方式","text":"装饰器Python装饰器能够动态地改变函数 方法 类的功能,而不用子类重写或修改函数源代码的方式 装饰器函数装饰器函数基础装饰器 增强了其他函数的功能 任何将函数作为传入参数并返回一个增强函数的函数都可以视为一个装饰器函数12345678910# 定义装饰器函数def decoratorFunc(f): return f# 语法糖 进行函数装饰@decoratorFunc# 定义待装饰函数def toBeEnforce(): print(&#x27;this function has been enforced&#x27;)# 调用增强后的函数toBeEnforce() 装饰器函数语法糖 @decoratorFunction作为语法糖:1@decoratorFunc 等效于:1my_function = super_secret_function(my_function) 以上代码等效于12345678910# 定义装饰器函数def decoratorFunc(f): return f# 定义待装饰函数def toBeEnforce(): print(&#x27;this function has been enforced&#x27;)# 进行装饰toBeEnforce = decoratorFunc(toBeEnforce)# 调用装饰后的函数toBeEnforce() 当然,此案例没有函数装饰作用装饰器函数理解 假设我们现有一个函数用于计算函数的sin cos值的函数:12345&gt;&gt;&gt; def calSinCos(alpha):... return [math.sin(alpha), math.cos(alpha)]...&gt;&gt;&gt; calSinCos(0.5)[0.479425538604203, 0.8775825618903728] 现需要这个函数输出这个角度半角的sin cos的值 solution1: ``calSinCos(aplha/2) 12&gt;&gt;&gt; calSinCos(0.5/2)[0.24740395925452294, 0.9689124217106447] solution2: 使用装饰器,使这个函数同时返回我们需要的两个值: 12345678910111213141516&gt;&gt;&gt; def decoratorCal(f):... def inner_function(*args, **kwargs):... temp_list_sin = []... temp_list_cos = []... for i in args:... temp_list_sin.append(math.sin(i))... temp_list_cos.append(math.cos(i))... return f(*args, **kwargs), temp_list_sin, temp_list_cos... return inner_function...&gt;&gt;&gt; @decoratorCal... def cal(a):... return [math.sin(a), math.cos(a)]...&gt;&gt;&gt; print(cal(0.3))([0.29552020666133955, 0.955336489125606], [0.29552020666133955], [0.955336489125606]) 装饰器函数工作流程: 调用待增强函数cal(0.3)时,同时调用装饰器函数decoratorCal decoratorCal内部定义了我们真正寄希望完成预期功能的函数inner_function return inner_function时便开始执行inner_function内代码,首先是完成基于原cal(0.3)的新加功能,最后return f(*args, **kwargs) 当然也可以return 其他想要的数据 不一定要返回原函数 return f(*args, **kwargs)便开始执行cal(0.3)原函数的功能 最后得到所有的返回值 从流程上看,cal原函数作为参数,真正运行的是inner_function,inner_function运行后返回cal,cal再运行本身的功能 之所以decoratorCal必须返回一个函数inner_function,是为了借return来执行inner_function内部我们新加功能的代码 装饰器更像是一种语法逻辑的产物 装饰器类将装饰器封装为类, 12345678910111213141516# 定义装饰器类class Decorator(object): # 初始化,将待装饰方法赋值给装饰器类,作为其属性(对象方法) def __init__(self, func): self.func = func def __call__(self, *args, **kwargs): # 调用此方法 res = self.func(*args, **kwargs) def testfunc(): print(&#x27;Inside the function.&#x27;)testfunc = Decorator(testfunc)testfunc()","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--列表推导式","slug":"Python/advance/列表推导式","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:36:00.594Z","comments":true,"path":"2021/07/07/Python/advance/列表推导式/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/","excerpt":"列表推导式列表推导式基础 result = [ &lt;expression&gt; for &lt;element&gt; in &lt;iterable&gt; ] 根据现有迭代器类iterable","text":"列表推导式列表推导式基础 result = [ &lt;expression&gt; for &lt;element&gt; in &lt;iterable&gt; ] 根据现有迭代器类iterable 对其中每个元素element 根据函数expression进行相应变化得到结果元素 将结果元素立即添加到result中123&gt;&gt;&gt; testSquares = [x * x for x in (1,2,3,4,5)]&gt;&gt;&gt; print(testSquares)[1, 4, 9, 16, 25] if条件(可选):result = [ &lt;expression&gt; for &lt;element&gt; in &lt;iterable&gt; if &lt;condition&gt; ] 每个元素在进行expression前。 所有结果将在新列表中立即返回。 Python 中的生成器表达式是懒惰地计算的，但是列表推导会立即施加到整个迭代器，它消耗与迭代器长度成比例的内存。123&gt;&gt;&gt; testSquares = [x * x for x in (1,2,3,4,5) if x % 2 == 0]&gt;&gt;&gt; print(testSquares)[4, 16] 12* 根据列表``(1,2,3,4,5)`` 创建一个平方数列表,* 只选择其中的偶数进行创建 else:if...else 判断是在 for 循环之前使用，而非以后： if...else在for后 报错12345&gt;&gt;&gt; testStr = [x for x in &#x27;abcd&#x27; if x is &#x27;a&#x27; else &#x27;b&#x27;] File &quot;&lt;stdin&gt;&quot;, line 1 testStr = [x for x in &#x27;abcd&#x27; if x is &#x27;a&#x27; else &#x27;b&#x27;] ^SyntaxError: invalid syntax if...else 在 for 前 123&gt;&gt;&gt; testStr = [x if x is &#x27;a&#x27; else &#x27;b&#x27; for x in &#x27;abcd&#x27;]&gt;&gt;&gt; print(testStr)[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;]","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--发生器","slug":"Python/advance/发生器","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:35:54.441Z","comments":true,"path":"2021/07/07/Python/advance/发生器/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/%E5%8F%91%E7%94%9F%E5%99%A8/","excerpt":"发生器 Python发生器通过关键字yeild创建 或通过发生器表达式 expression for x in an_iterator创建","text":"发生器 Python发生器通过关键字yeild创建 或通过发生器表达式 expression for x in an_iterator创建 生成器保存的算法而非具体数据,因此节约了内存 发生器 发生器返回对象为 generator 发生器表达式 发生器类似于列表推导式,但发生器用()声明 当发生器作为函数的唯一参数时,不必多重括号: 1234567891011121314151617&gt;&gt;&gt; def printL(list1):... for i in list1:... print(i)...&gt;&gt;&gt; printL(x * 2 for x in range(10))024681012141618&gt;&gt;&gt; print((x * 2 for x in range(10)).__class__)&lt;class &#x27;generator&#x27;&gt; 发生器函数 生成器函数类似常规函数 生成器函数内部有多个或一个yield关键字 生成器函数无返回值 return 如果要提前停止发生器,则提前使用空return 12345678910111213&gt;&gt;&gt; def generatorFunc():... for i in range(5):... yield i * 2...&gt;&gt;&gt; l = generatorFunc()&gt;&gt;&gt; for i in l:... print(i)...02468 所有的生成器表达式都有自己对应的生成器函数,反之亦然一次性生成器对象是一次性的,当一次迭代完成后,则该生成器对象内部函数被销毁 12345678910111213&gt;&gt;&gt; l = generatorFunc()&gt;&gt;&gt; for i in l:... print(i)...02468&gt;&gt;&gt; print(next(l))Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 生成器的主体不会立即执行：当调用生成器函数时，它只会返回生成器对象，而不去执行第一个 print 语句。 这使得生成器比返回列表的函数消耗更少的内存，并且它能够实现生成无限长的序列。 因此,生成器通常用于数据科学以及涉及大量数据的其他环境。 另一个优点是其他代码可以立即使用生成器产生的值，而无需等待生成完整的序列。 但是，如果你需要多次使用生成器生成的值，并且如果生成它们的成本高于存储，则将 list 生成的值存储为比重新生成序列更好。 .next()函数用于从生成器中获取值,并提供迭代结束的默认值","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--多线程","slug":"Python/advance/多线程","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:35:48.758Z","comments":true,"path":"2021/07/07/Python/advance/多线程/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"多线程python多线程并非真正意义上的多线程 每个进程运行时都需要等到GIL释放,然后得到GIL后上锁 因此,同一时间只有一个python线程在运行","text":"多线程python多线程并非真正意义上的多线程 每个进程运行时都需要等到GIL释放,然后得到GIL后上锁 因此,同一时间只有一个python线程在运行 创建线程 threading.Thread使用threading,创建新的threading.Thread,为其分配要执行的函数来启动新的执行线程12345&gt;&gt;&gt; import threading&gt;&gt;&gt; def test():... print(&quot;Running...&quot;)...&gt;&gt;&gt; test_thread = threading.Thread(target=test) target 传入函数或可调用对象 在Thread调用start()方法前,线程不会开始 开始线程 Thread.start()Thread.start()开始线程 12&gt;&gt;&gt; test_thread.start()Running... 当一个线程运行结束,再次调用start()方法,则会报错: 12345678&gt;&gt;&gt; test_thread.start()Running...&gt;&gt;&gt; test_thread.start()Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;File &quot;D:\\Python37\\lib\\threading.py&quot;, line 848, in start raise RuntimeError(&quot;threads can only be started once&quot;)RuntimeError: threads can only be started once 若想将线程设置为守护线程持续运行,则需设置daemon=True 加入线程 Thread.join()","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--拷贝","slug":"Python/advance/数据拷贝","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:36:02.929Z","comments":true,"path":"2021/07/07/Python/advance/数据拷贝/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D/","excerpt":"拷贝 浅拷贝(shallow copy), 仅拷贝指向对象的指针 深拷贝(`deep copy``),将整个对象拷贝至另外一块内存","text":"拷贝 浅拷贝(shallow copy), 仅拷贝指向对象的指针 深拷贝(`deep copy``),将整个对象拷贝至另外一块内存 浅拷贝 假设原有一个列表la = [1,2,3,[4,5,6]],将其浅拷贝到lb lb中某个元素改变时,会直接根据指针指向此列表所在内存,改变此列表值 最终la值也改变 1234567&gt;&gt;&gt; la = [1,2,3,[4,5,6]]&gt;&gt;&gt; lb = la&gt;&gt;&gt; lb[0] = &#x27;a&#x27;&gt;&gt;&gt; print(lb)[&#x27;a&#x27;, 2, 3, [4, 5, 6]]&gt;&gt;&gt; print(la)[&#x27;a&#x27;, 2, 3, [4, 5, 6]] 12345&gt;&gt;&gt; a = [1,2,[3,4]]&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; b[2][1] = 0 &gt;&gt;&gt; print(a)[1, 2, [3, 0]] 深拷贝通过引入copy,使用copy.deepcopy()方法12345678&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1,2,[3,4]]&gt;&gt;&gt; c = copy.deepcopy(a)&gt;&gt;&gt; c[2][1] = 99&gt;&gt;&gt; print(c)[1, 2, [3, 99]]&gt;&gt;&gt; print(a)[1, 2, [3, 0]]","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--运算符重载","slug":"Python/advance/运算符重载","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:36:11.392Z","comments":true,"path":"2021/07/07/Python/advance/运算符重载/","link":"","permalink":"http://example.com/2021/07/07/Python/advance/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"运算符重载 python中一切都是对象,每个对象都有一些特殊的内部方法 这些方法都遵循__action__的命名规定","text":"运算符重载 python中一切都是对象,每个对象都有一些特殊的内部方法 这些方法都遵循__action__的命名规定 通过运算符重载,可以让类进行一些数学运算123456789101112131415161718192021222324252627282930313233343536373839class Vector(object): def __init__(self, x, y): self.x = x self.y = y def __add__(self, v): # Addition with another vector. return Vector(self.x + v.x, self.y + v.y) def __sub__(self, v): # Subtraction with another vector. return Vector(self.x - v.x, self.y - v.y) def __mul__(self, s): # Multiplication with a scalar. return Vector(self.x * s, self.y * s) def __div__(self, s): # Division with a scalar. float_s = float(s) return Vector(self.x / float_s, self.y / float_s) def __floordiv__(self, s): # Division with a scalar (value floored). return Vector(self.x // s, self.y // s) def __repr__(self): # Print friendly representation of Vector class. Else, it would # show up like, &lt;__main__.Vector instance at 0x01DDDDC8&gt;. return &#x27;&lt;Vector (%f, %f)&gt;&#x27; % (self.x, self.y, )a = Vector(3, 5)b = Vector(2, 7)print a + b # Output: &lt;Vector (5.000000, 12.000000)&gt;print b - a # Output: &lt;Vector (-1.000000, 2.000000)&gt;print b * 1.3 # Output: &lt;Vector (2.600000, 9.100000)&gt;print a // 17 # Output: &lt;Vector (0.000000, 0.000000)&gt;print a / 17 # Output: &lt;Vector (0.176471, 0.294118)&gt;","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--数组","slug":"Python/basic/数组","date":"2021-07-07T07:22:24.000Z","updated":"2021-07-10T14:36:51.080Z","comments":true,"path":"2021/07/07/Python/basic/数组/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E6%95%B0%E7%BB%84/","excerpt":"数组-array数组的基本性质: 数组本身不属于基本数据类型,需要导入array使用数组 数组内部元素类型相同","text":"数组-array数组的基本性质: 数组本身不属于基本数据类型,需要导入array使用数组 数组内部元素类型相同 数组不同于列表:内部元素相同,列表内部元素可以不同 人如其名,内部元素只能是数字数组定义 声明一个数组,必须遵循基本语法:arrayName = array(typecode, [initializers]): typecode:str 123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,2,3,4])&gt;&gt;&gt; print(arr1, arr1.__class__)array(&#x27;i&#x27;, [1, 2, 3, 4]) &lt;class &#x27;array.array&#x27;&gt; 当声明数据类型与initializers数据类型不一,则报错: 1234&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,2.2,3,4])Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: integer argument expected, got float 指定数据类型后,initializers可为空: 123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[])&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;) 访问数组索引–[]123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,3,4,5,6,7,5])&gt;&gt;&gt; print(arr1[1])3 切片–:12&gt;&gt;&gt; print(arr1[1:])array(&#x27;i&#x27;, [3, 4, 5, 6, 7, 5]) index(x)返回首次出现x的最小索引123&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;,[1,3,4,5,6,7,5])&gt;&gt;&gt; print(arr1.index(5))3 负索引修改数组append()将一个元素添加到数组末尾1234&gt;&gt;&gt; a = array(&#x27;i&#x27;, [1,2,3,4,5,7,8,9])&gt;&gt;&gt; a.append(10)&gt;&gt;&gt; print(a)array(&#x27;i&#x27;, [1, 2, 3, 4, 5, 7, 8, 9, 10]) insert(x, i)将元素x指定添加到i处1234&gt;&gt;&gt; a = array(&#x27;i&#x27;, [1,2,3])&gt;&gt;&gt; a.insert(1, 22)&gt;&gt;&gt; print(a)array(&#x27;i&#x27;, [1, 22, 2, 3]) extend(x)将x元素添加到数组,若x时数组,则二者应有相同的数据类型12345&gt;&gt;&gt; arr1 = array(&#x27;i&#x27;, [1,2,3])&gt;&gt;&gt; arr2 = array(&#x27;i&#x27;, [3,4,5])&gt;&gt;&gt; arr1.extend(arr2)&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [1, 2, 3, 3, 4, 5]) fromlist()将list中的元素添加到数组中12345&gt;&gt;&gt; a = array(&#x27;i&#x27;, [1,2,3,4,5,7,8,9])&gt;&gt;&gt; l = [10,11]&gt;&gt;&gt; a.fromlist(l)&gt;&gt;&gt; print(a)array(&#x27;i&#x27;, [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]) reverse()反转数组12345678910&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [1, 2, 3, 3, 4, 5])&gt;&gt;&gt; print(arr1.reverse())None&gt;&gt;&gt; arr1.reverse()&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [1, 2, 3, 3, 4, 5])&gt;&gt;&gt; arr1.reverse()&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [5, 4, 3, 3, 2, 1]) +将两个数组拼接12&gt;&gt;&gt; print(arr1 + arr2)array(&#x27;i&#x27;, [5, 4, 3, 3, 2, 1, 3, 4, 5]) *将数组复制添加到本身12&gt;&gt;&gt; print(arr1*2)array(&#x27;i&#x27;, [5, 4, 3, 3, 2, 1, 5, 4, 3, 3, 2, 1]) del arr[i]删除某个元素,或数组12345&gt;&gt;&gt; arr1array(&#x27;i&#x27;, [4, 3, 3, 2, 1])&gt;&gt;&gt; del arr1[0]&gt;&gt;&gt; print(arr1)array(&#x27;i&#x27;, [3, 3, 2, 1]) 12345&gt;&gt;&gt; del arr1&gt;&gt;&gt; print(arr1)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;arr1&#x27; is not defined remove()从数组中删除第一个出现的x元素12345&gt;&gt;&gt; arr2array(&#x27;i&#x27;, [3, 4, 5, 3, 4, 5])&gt;&gt;&gt; arr2.remove(3)&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 3, 4, 5]) pop()删除并返回数组的最后一个元素12345&gt;&gt;&gt; arr2array(&#x27;i&#x27;, [3, 4, 5, 3, 4, 5])&gt;&gt;&gt; arr2.remove(3)&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 3, 4, 5]) 也可指定pop对象索引123456&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 3, 4])&gt;&gt;&gt; arr2.pop(2)3&gt;&gt;&gt; print(arr2)array(&#x27;i&#x27;, [4, 5, 4])","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Pyhont--字典","slug":"Python/basic/字典","date":"2021-07-07T07:02:24.000Z","updated":"2021-07-10T14:36:59.106Z","comments":true,"path":"2021/07/07/Python/basic/字典/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E5%AD%97%E5%85%B8/","excerpt":"字典-Dictionary字典的基本性质: 字典是python的内置数据类型 字典的数据是键值对一一对应,根据键索引指定值","text":"字典-Dictionary字典的基本性质: 字典是python的内置数据类型 字典的数据是键值对一一对应,根据键索引指定值 创建字典1. 使用&#123;&#125;创建字典,声明其类型 字典键是不可变数据类型,用元组或不可变集合创建 字典值是可变数据类型12345&gt;&gt;&gt; dict1 = &#123;1:&#x27;value1&#x27;, &#x27;key2&#x27;:&#x27;value2&#x27;&#125;&gt;&gt;&gt; print(type(dict1))&lt;class &#x27;dict&#x27;&gt;&gt;&gt;&gt; print(dict1[1])value1 键只能是不可变数据类型:元组 不可变集合值都可 123&gt;&gt;&gt; dict1 = &#123;tp1:tp1&#125;&gt;&gt;&gt; print(dict1, dict1.__class__)&#123;(3, 2, 11): (3, 2, 11)&#125; &lt;class &#x27;dict&#x27;&gt; 2. 使用dict()初始化字典 12345&gt;&gt;&gt; d&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[2]&#x27;Pink&#x27; 访问字典键12345678&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[2]&#x27;Pink&#x27;&gt;&gt;&gt; d[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 3 []索引找不到值则报错 get()123456789101112131415&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[2]&#x27;Pink&#x27;&gt;&gt;&gt; d[1]&#x27;Blue&#x27;&gt;&gt;&gt; d.get(1)&#x27;Blue&#x27;&gt;&gt;&gt; d[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 3&gt;&gt;&gt; d.get(3)&gt;&gt;&gt; print(d.get(3))None 当.get()方法找不到值,则返回None 更新值使用键定位,更新值 12345&gt;&gt;&gt; d&#123;1: &#x27;Blue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[1] = &#x27;cjblue&#x27;&gt;&gt;&gt; print(d)&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;&#125; 直接使用新键,则添加新值 12345&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;&#125;&gt;&gt;&gt; d[5] = &#x27;marklily&#x27;&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;, 5: &#x27;marklily&#x27;&#125; 删除元素1. pop() 删除并返回给定键的值 123456&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 2: &#x27;Pink&#x27;, 5: &#x27;marklily&#x27;&#125;&gt;&gt;&gt; d.pop(2)&#x27;Pink&#x27;&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;&#125; 2. popitem() 删除并返回任意一个键值对 123456&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;, 3: &#x27;floyd&#x27;&#125;&gt;&gt;&gt; d.popitem()(3, &#x27;floyd&#x27;)&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;&#125; 3. clear() 删除所有元素但不删除字典本身 123&gt;&gt;&gt; d.clear()&gt;&gt;&gt; d&#123;&#125; 4. del 删除特定键值对或删除整个字典 12345678910&gt;&gt;&gt; d&#123;1: &#x27;cjblue&#x27;, 5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;, 3: &#x27;floyd&#x27;&#125;&gt;&gt;&gt; del d[1]&gt;&gt;&gt; d&#123;5: &#x27;marklily&#x27;, 2: &#x27;pink&#x27;, 3: &#x27;floyd&#x27;&#125;&gt;&gt;&gt; del d&gt;&gt;&gt; dTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;d&#x27; is not defined","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"python--递归","slug":"Python/basic/递归","date":"2021-07-07T05:40:24.000Z","updated":"2021-07-10T14:36:29.588Z","comments":true,"path":"2021/07/07/Python/basic/递归/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/%E9%80%92%E5%BD%92/","excerpt":"递归","text":"递归 举例计算阶乘 12345678910&gt;&gt;&gt; def cal(n):... if n == 1:... return 1... else:... return n * cal(n - 1)...&gt;&gt;&gt; print(cal(4))24&gt;&gt;&gt; print(cal(6))720 递归函数内部会调用函数本身 某次调用递归函数时,内部调用本身时会指定参数 在递归函数中,应有一个结束参数信号,在每次递归中,参数不断靠近该信号递归次数限制python递归次数限制为3000次,超出此次数则会触发RecursionError移除递归次数限制sys.setrecursionlimit(5000) 设置次数限制为我们所需要的次数","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Pandas--基础","slug":"Python/basic/Pandas基础","date":"2021-07-07T02:40:24.000Z","updated":"2021-07-11T16:55:20.155Z","comments":true,"path":"2021/07/07/Python/basic/Pandas基础/","link":"","permalink":"http://example.com/2021/07/07/Python/basic/Pandas%E5%9F%BA%E7%A1%80/","excerpt":"2142Pandas数据结构pandas有两种数据结构：Series and dataframe数据框","text":"2142Pandas数据结构pandas有两种数据结构：Series and dataframe数据框 SeriesSeries是一个一维标记数组，可以存储任何种类的数据 12my_series = pd.Series([3,-5,7,4], index=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])print(my_series) 12345a 3b -5c 7d 4dtype: int64 Series中的数据可通过index找到 1print(my_series[&#x27;d&#x27;]) 14 series类似于字典(当然这只是个人直观感受) dataframe是一个二维数据结构,包含不同的列 12345678data = &#123; &#x27;Country&#x27; : [&#x27;Belgium&#x27;, &#x27;India&#x27;, &#x27;Brazil&#x27; ], &#x27;Capital&#x27;: [&#x27;Brussels&#x27;, &#x27;New Delhi&#x27;, &#x27;Brassilia&#x27;], &#x27;Population&#x27;: [1234,1234,1234]&#125;datas = pd.DataFrame(data, columns=[&#x27;Country&#x27;,&#x27;Capital&#x27;,&#x27;Population&#x27;])print(type(data))print(type(datas))print(datas) 123456&lt;class &#x27;dict&#x27;&gt;&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;Country Capital Population0 Belgium Brussels 12341 India New Delhi 12342 Brazil Brassilia 1234 创建dataframe时,在写入或打印时会自动生成从第一行正式数据开始的行序号 and 第一列正式数据开始的列序号dataframe类似于数组,可直接使用行列序号进行访问具体的数据 调用/读取数据 CSV文件 12pd = pd.read_csv(&#x27;.//testdata/demo1.csv&#x27;)print(pd.__class__) 1&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; xlsx文件 12df = pd.read_excel(&#x27;.//testdata/demo1.xlsx&#x27; )print(df.__class__) 1&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; 数据存储各类文件读取成为dataframe数据后可随意转存为其他格式的文件 12345678910df_cvs = pd.read_csv(&#x27;.//testdata/demo1.csv&#x27; )df_xlsx = pd.read_excel(&#x27;.//testdata/demo1.xlsx&#x27; )# csv读取的文件保存为csvdf_cvs.to_csv(&#x27;csv_to_csv.csv&#x27;)# excel读取的数据保存为exceldf_xlsx.to_excel(&#x27;xlsx_to_xlsx.xlsx&#x27;)# csv读取的数据保存为exceldf_cvs.to_excel(&#x27;csv_to_xlsx.xlsx&#x27;)# excel读取的数据保存为csvdf_xlsx.to_csv(&#x27;xlsx_to_csv.csv&#x27;) 创建测试对象创建一个20 × 5 的随机数的数据框(dataframe) 使用np生成矩阵的形式创建dataframe’ 12test_data = pd.DataFrame(np.random.randint(0, 20, size=(20, 5)))print(test_data) 直接输入生成 1234567df = pd.DataFrame(&#123;&quot;id&quot;:[1001,1002,1003,1004,1005,1006], &quot;date&quot;:pd.date_range(&#x27;20130102&#x27;, periods=6),&quot;city&quot;:[&#x27;Beijing &#x27;, &#x27;SH&#x27;, &#x27; guangzhou &#x27;, &#x27;Shenzhen&#x27;, &#x27;shanghai&#x27;, &#x27;BEIJING &#x27;],&quot;age&quot;:[23,44,54,32,34,32],&quot;category&quot;:[&#x27;100-A&#x27;,&#x27;100-B&#x27;,&#x27;110-A&#x27;,&#x27;110-C&#x27;,&#x27;210-A&#x27;,&#x27;130-F&#x27;],&quot;price&quot;:[1200,np.nan,2133,5433,np.nan,4432]&#125;,) 可在{}内数据内容后添加columns =[&#39;id&#39;,&#39;date&#39;,&#39;city&#39;,&#39;category&#39;,&#39;age&#39;,&#39;price&#39;],借此自定义dataframe内数据的列次序统计数据函数 df.info() :本函数提供dataframe的以下信息: RangeIndex:有多少数据 Data Columns:指定找到多少列 Columns:提供关于columns的信息 dtypes:提供dataframe内的数据类型 memory usage:表明内存使用量12test_data = pd.DataFrame(np.random.randint(0, 20, size=(20, 5)))print(test_data.info() 12345678910111213&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;RangeIndex: 20 entries, 0 to 19Data columns (total 5 columns):# Column Non-Null Count Dtype--- ------ -------------- -----0 0 20 non-null int321 1 20 non-null int322 2 20 non-null int323 3 20 non-null int324 4 20 non-null int32dtypes: int32(5)memory usage: 528.0 bytesNone df.shape 1print(test_data.shape) 1(20, 5) 类似于数组,shape作为属性,而非函数 df.index():显示找到的索引信息 1print(test_data.index) 1RangeIndex(start=0, stop=20, step=1) index作为属性 not callable df.count():给出每一列中有多少数据 1print(test_data.count()) 1234560 201 202 203 204 20dtype: int64 df.sum():给出每一列中的求和 1print(test_data.sum()) 1234560 2001 1192 2403 2144 204dtype: int64 df.sum():给出每一列中的求和 1print(test_data.sum()) 1234560 2001 1192 2403 2144 204dtype: int64 df.cumsum() 给出依次将每列前n行求和的结果 1print(test_data.cumsum()) 12345678910111213 id date city category age price0 1001 2013-01-02 Beijing 100-A 23 1200.01 1002 2013-01-03 SH 100-B 44 NaN2 1003 2013-01-04 guangzhou 110-A 54 2133.03 1004 2013-01-05 Shenzhen 110-C 32 5433.05 1006 2013-01-07 BEIJING 130-F 32 4432.0id date city category age price 0 1001 2013-01-02 Beijing 100-A 23 1200.0 1 2003 2056-01-05 Beijing SH 100-A100-B 67 NaN 2 3006 2099-01-08 Beijing SH guangzhou 100-A100-B110-A 121 3333.0 3 4010 2142-01-13 Beijing SH guangzhou Shenzhen 100-A100-B110-A110-C 153 8766.0 4 5015 2185-01-18 Beijing SH guangzhou Shenzhenshanghai 100-A100-B110-A110-C210-A 187 NaN 5 6021 2228-01-26 Beijing SH guangzhou ShenzhenshanghaiBEIJING 100-A100-B110-A110-C210-A130-F 219 13198.0 所得结果依然为dataframe 指定列时，只计算该列的累加值: tar = df[‘id’].cumsum() 不指定列时，则将返回各列的累加值 df.min():给出每列中的最小值 12345678id 1001date 2013-01-02 00:00:00city guangzhou category 100-Aage 23price 1200.0dtype: object &lt;class &#x27;pandas.core.series.Series&#x27;&gt; 所得结果为Series df.describe():函数提供了有关数据的基本统计信息（基于列计算）：count、mean、std、min、25%、50%、75%、max 12345678910 id age pricecount 6.000000 6.00000 4.000000mean 1003.500000 36.50000 3299.500000std 1.870829 10.87658 1966.638503min 1001.000000 23.00000 1200.00000025% 1002.250000 32.00000 1899.75000050% 1003.500000 33.00000 3282.50000075% 1004.750000 41.50000 4682.250000max 1006.000000 54.00000 5433.000000 &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.mean():给出每列中的均值 123456tar = df.mean()id 1003.5age 36.5price 3299.5dtype: float64&lt;class &#x27;pandas.core.series.Series&#x27;&gt; 只针对dataframe中的数字 df.median():给出每列中的中位数 df.quantlie([0.25, 0.75]):给出每列中的25% 和 75%的分位数 df.var()–方差值 df.std()–标准差值 df.cummin()–返回前n行的最小值 len(df):确定列的行数 len(df[‘columnId’]):返回某列的行数 df.count():返回Nan值个数 df.isnull():返回dataframe中各值是否为null return DataFrame df.corr():返回各列之间的相关系数 pandas中的选择与过滤 Series: mySeries[‘index’]–返回索引值为’index’的value df[n:N]–返回行n到N-1的dataframe 1tar =df[2:5] 12345id date city category age price2 1003 2013-01-04 guangzhou 110-A 54 2133.03 1004 2013-01-05 Shenzhen 110-C 32 5433.04 1005 2013-01-06 shanghai 210-A 34 NaN&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.head()–返回dataframe中的前几行,默认为5行 df.tail() df.sample()–随机选取几行,按频数 create filter–创建一个过滤条件 12filters = df.id &gt; 1003df[filter] 12343 1004 2013-01-05 Shenzhen 110-C 32 5433.04 1005 2013-01-06 shanghai 210-A 34 NaN5 1006 2013-01-07 BEIJING 130-F 32 4432.0 &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.filter(regex = ‘code’)–表示regex = ‘code’的列通过过滤条件 1tar = df.filter(regex=&#x27;date&#x27;).head() 1234567 date0 2013-01-021 2013-01-032 2013-01-043 2013-01-054 2013-01-06&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; np.logicl_and(filter1, filter2)–并行多个filter 1tar =df[np.logical_and(df[&#x27;id&#x27;] &gt; 1003, df[&#x27;age&#x27;] &gt; 33)] 14 1005 2013-01-06 shanghai 210-A 34 NaN df[(filter1) &amp; (filter2)] 1tar =df[(df[&#x27;id&#x27;] &gt; 1003) &amp; (df[&#x27;age&#x27;] &gt; 33)] sort data df.sort_values(‘columnName’, ascending=True) 对columnName列排序 ascending=true表示升序1df.sort_values(&#x27;age&#x27;, ascending=True) 123456789101112131415 id date city category age price0 1001 2013-01-02 Beijing 100-A 23 1200.01 1002 2013-01-03 SH 100-B 44 NaN2 1003 2013-01-04 guangzhou 110-A 54 2133.03 1004 2013-01-05 Shenzhen 110-C 32 5433.04 1005 2013-01-06 shanghai 210-A 34 NaN5 1006 2013-01-07 BEIJING 130-F 32 4432.0 id date city category age price0 1001 2013-01-02 Beijing 100-A 23 1200.03 1004 2013-01-05 Shenzhen 110-C 32 5433.05 1006 2013-01-07 BEIJING 130-F 32 4432.04 1005 2013-01-06 shanghai 210-A 34 NaN1 1002 2013-01-03 SH 100-B 44 NaN2 1003 2013-01-04 guangzhou 110-A 54 2133.0&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt; df.sort_index() 对索引按照默认升序1df.sort_index() 12345### 重命名&amp;定义\\修改新的列1. df.rename(columns = &#123;&#x27;oldColumnName&#x27;:&#x27;newColumnName&#x27;&#125;) * 重命名 9 ```python tar = df.rename(columns = &#123;&#x27;id&#x27;:&#x27;newId&#x27;&#125;) df[‘newColume’] = newDesignWay 1df[&#x27;thisisanewcolumn&#x27;] = pd.Series(np.arange(0, 6, 1)) 1234567 id date city category age price thisisanewcolumn0 1001 2013-01-02 Beijing 100-A 23 1200.0 01 1002 2013-01-03 SH 100-B 44 NaN 12 1003 2013-01-04 guangzhou 110-A 54 2133.0 23 1004 2013-01-05 Shenzhen 110-C 32 5433.0 34 1005 2013-01-06 shanghai 210-A 34 NaN 45 1006 2013-01-07 BEIJING 130-F 32 4432.0 5 df.index.name = “index_name” 修改index为新index12345 ```4. df.columns = map(str.lower, df.columns) * 所有列名变大写字母 ```python df.columns = map(str.lower, df.columns) map()–python的内置函数,接受一个function,数个待迭代的list,使用function对list进行处理得到新的list,并不改变原list Drop Data df.drop(columns=[‘columnName’]) 指定删除某列数据1tar = df.drop(columns=[&#x27;Id&#x27;]) mySeries.drop([‘a’]) 指定删除索引值指向的value f.drop(‘Volume’, axis=1) 删除一个变量\\一个量1tar = df.drop(&#x27;Id&#x27;, axis=1) 转换数据类型 df.dtypes dataframe内各列的数据类型 df[‘columnName’] = df[‘columnName’].astype(‘dataType’) 转换指定行的数据类型1df[&#x27;Id&#x27;] = df[&#x27;Id&#x27;].astype(&#x27;float&#x27;) apply函数 方法1–自定义def函数 1234def examples(x): #create a functionreturn x*2df.Open.apply(examples).head() #use the function with apply() 自定义函数后,df.ColumnName获取df中需要使用此函数的列,再对此列使用apply函数,传入需要使用的函数 lambda函数 1df.Open.apply(lambda x: x*2).head() df.ColumnName获取df中需要使用此函数的列,再对此列使用lambda 声明数据处理方法","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"pandas","slug":"Python/pandas","permalink":"http://example.com/categories/Python/pandas/"}],"tags":[{"name":"Pandas","slug":"Pandas","permalink":"http://example.com/tags/Pandas/"}]}],"categories":[{"name":"Git","slug":"Git","permalink":"http://example.com/categories/Git/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"basic","slug":"Python/basic","permalink":"http://example.com/categories/Python/basic/"},{"name":"Numpy","slug":"Python/Numpy","permalink":"http://example.com/categories/Python/Numpy/"},{"name":"advance","slug":"Python/advance","permalink":"http://example.com/categories/Python/advance/"},{"name":"pandas","slug":"Python/pandas","permalink":"http://example.com/categories/Python/pandas/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://example.com/tags/Numpy/"},{"name":"Pandas","slug":"Pandas","permalink":"http://example.com/tags/Pandas/"}]}